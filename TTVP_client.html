<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TTVP Client - Interstellar Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <!--<link rel="stylesheet" href="fonts/fonts.css"> 
        <!-- added additionally to include custom font CSS -->
        <link rel="stylesheet" href="its-theme/fonts/BF_Modernista.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="its-theme/fonts/BF_Modernista.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="GCF.html"><strong aria-hidden="true">1.</strong> Garbled Circuit Factory - GCF</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="GC.html"><strong aria-hidden="true">1.1.</strong> Garbled Circuit Overview</a></li><li class="chapter-item expanded "><a href="VC-GC.html"><strong aria-hidden="true">1.2.</strong> Visual Cryptography Display</a></li><li class="chapter-item expanded "><a href="GCF_pipeline_detailed.html"><strong aria-hidden="true">1.3.</strong> Detailed Pipeline for Display Circuits</a></li><li class="chapter-item expanded "><a href="GCF_API.html"><strong aria-hidden="true">1.4.</strong> Garbled Circuit Factory APIs</a></li></ol></li><li class="chapter-item expanded "><a href="TTVP.html"><strong aria-hidden="true">2.</strong> Trusted Transaction Validation Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TAUI.html"><strong aria-hidden="true">2.1.</strong> Trusted Authentication & UI Layer</a></li><li class="chapter-item expanded "><a href="TTVP_detailed.html"><strong aria-hidden="true">2.2.</strong> TTVP detailed</a></li><li class="chapter-item expanded "><a href="TTVP-TEE.html"><strong aria-hidden="true">2.3.</strong> TTVP in Hardware Enclave-TEE</a></li></ol></li><li class="chapter-item expanded "><a href="Mobile_Registry.html"><strong aria-hidden="true">3.</strong> Mobile Registry</a></li><li class="chapter-item expanded "><a href="Mobile_App.html"><strong aria-hidden="true">4.</strong> Mobile Wallet App</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TTVP_client.html" class="active"><strong aria-hidden="true">4.1.</strong> TTVP Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HBMK.html"><strong aria-hidden="true">4.1.1.</strong> Hardware-backed Mobile Key</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime_prerequisite.html"><strong aria-hidden="true">5.1.</strong> Runtime prerequisite</a></li><li class="chapter-item expanded "><a href="compilation_prerequisite.html"><strong aria-hidden="true">5.2.</strong> compilation prerequisite</a></li><li class="chapter-item expanded "><a href="M1.html"><strong aria-hidden="true">5.3.</strong> M1 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M1_demo_tutorial.html"><strong aria-hidden="true">5.3.1.</strong> M1 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="M2.html"><strong aria-hidden="true">5.4.</strong> M2 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M2_demo_tutorial.html"><strong aria-hidden="true">5.4.1.</strong> M2 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="M3.html"><strong aria-hidden="true">5.5.</strong> M3 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M3_demo_tutorial.html"><strong aria-hidden="true">5.5.1.</strong> M3 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="M4.html"><strong aria-hidden="true">5.6.</strong> M4 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M4_demo_tutorial.html"><strong aria-hidden="true">5.6.1.</strong> M3 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="GCF_API_Test_Guide.html"><strong aria-hidden="true">5.7.</strong> GCF APIs Testing Guide</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Interstellar Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="trusted-transaction-validation-protocol-client"><a class="header" href="#trusted-transaction-validation-protocol-client">Trusted Transaction Validation Protocol client</a></h1>
<p>This is the client software embedded in an app or browser in the future that  enables the secure confirmation of any transactions or sensitive operation with an hardware level security.
(cf <a href="./TTVP.html">Tusted Transaction Validation Protocol</a>)</p>
<p>It implements the <a href="./TAUI.html">Trusted Authentication and User Interface Layer</a> combined with <a href="./HBMK.html">Harware-backed Mobile Key</a> and is regsitered in the <a href="./Mobile_Registry.html">Mobile TEE Registry</a></p>
<h2 id="architecture-and-security"><a class="header" href="#architecture-and-security">Architecture and Security</a></h2>
<p><img src="./fig/App_architecture.svg" alt="App architecture" /></p>
<blockquote>
<p>Green boxes are secure as well as garbled circuit evaluation in Dark Grey
it prevents state of the art Banking trojan attacks on the mobile</p>
</blockquote>
<p>This client is based on a substrate client on the mobile to communicate through unsigned extrinsic with signed option and substrate events with the blockchain. It enables the mobile to be registered with the mobile TEE registry pallet. </p>
<p>It also include an IPFS client to retrieve the cid of the <a href="./VC-GC.html">Visual Cryptography Display</a> i.e the one-time <a href=",/GC.html">Garbled Circuit</a> program generated for each transaction  by the <a href="./GCF.html">Garbled Circuit Factory</a> managed by the blockchain.</p>
<p>The previous circuit is used to compose the <a href="./TAUI.html">Trusted Authentication and User Interface Layer</a> i.e <code>Secure UI Screen</code> that evaluates and renders the circuit to enable the user to confirm a transaction/sensitive operation with a <code>one-time code</code></p>
<p>This Secure UI layer relies on a garbled circuit evaluator and a renderer to display the result of its evaluation directly to the framebuffer.</p>
<h2 id="ttvp-client-components"><a class="header" href="#ttvp-client-components">TTVP client components</a></h2>
<p>Following are the main components of the mobile client</p>
<h3 id="substrate-client"><a class="header" href="#substrate-client">Substrate Client</a></h3>
<p><a href="https://github.com/Interstellar-Network/wallet-app/blob/master/shared/rust/substrate-client/src/lib.rs">wallet-app/shared/rust/substrate-client/src</a></p>
<p>following are the main extrinsics used</p>
<h4 id="extrinsic_garble_and_strip_display_circuits_package_signed"><a class="header" href="#extrinsic_garble_and_strip_display_circuits_package_signed"><code>extrinsic_garble_and_strip_display_circuits_package_signed</code></a></h4>
<p>Get garbled Circuit package from ocwGarble pallet</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extrinsic_garble_and_strip_display_circuits_package_signed(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    tx_message: &amp;str,
) 
<span class="boring">}
</span></code></pre></pre>
<h4 id="extrinsic_register_mobile"><a class="header" href="#extrinsic_register_mobile"><code>extrinsic_register_mobile</code></a></h4>
<p>send the mobile public key to be registered in the Mobile Registry pallet</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extrinsic_register_mobile(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    pub_key: Vec&lt;u8&gt;,
) 
<span class="boring">}
</span></code></pre></pre>
<h4 id="extrinsic_check_input"><a class="header" href="#extrinsic_check_input"><code>extrinsic_check_input</code></a></h4>
<p>check user input i.e one-time-code inputted on the randomized keypad</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extrinsic_check_input(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    ipfs_cid: Vec&lt;u8&gt;,
    input_digits: Vec&lt;u8&gt;,
) 
<span class="boring">}
</span></code></pre></pre>
<h3 id="garble-circuit-evaluator"><a class="header" href="#garble-circuit-evaluator">Garble Circuit Evaluator</a></h3>
<p>This is the high level part in rust that encapsulated calls to lower level C++ evaluator</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use cxx;

use aes::cipher::{
    generic_array::{typenum::consts::U16, GenericArray},
    BlockEncrypt, KeyInit,
};
use aes::Aes128;

#[cxx::bridge]
pub mod ffi {

    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MyRustAes;

        unsafe fn encrypt_block(aes: &amp;MyRustAes, low: &amp;mut u64, high: &amp;mut u64);

        /// param: key: usually a PGC's global_key field
        // Box&lt;&gt; else &quot;returning opaque Rust type by value is not supported&quot;
        unsafe fn init_aes(key_low: u64, key_high: u64) -&gt; Box&lt;MyRustAes&gt;;
    }

    unsafe extern &quot;C++&quot; {
        include!(&quot;circuit-evaluate/src/rust_wrapper.h&quot;);

        type EvaluateWrapper;

        /// Create a new EvaluateWrapper, to be used later eg
        /// let evaluate_wrapper = ffi::new_evaluate_wrapper(...);
        /// evaluate_wrapper.EvaluateWithInputs(...); etc
        ///
        /// param: pgarbled_buffer can be a FULL, or a STRIPPED circuit
        /// typically in PROD we use STRIPPED ones, but for tests/dev we keep compat with FULL circuits
        /// [in which case] packmsg_buffer can be empty
        fn new_evaluate_wrapper(
            pgarbled_buffer: Vec&lt;u8&gt;,
            packmsg_buffer: Vec&lt;u8&gt;,
        ) -&gt; UniquePtr&lt;EvaluateWrapper&gt;;

        /// PROD version
        /// inputs are randomized, outputs are externally given
        /// typically outputs points to some kind of &quot;Texture data&quot;
        fn EvaluateWithPackmsg(self: Pin&lt;&amp;mut EvaluateWrapper&gt;, outputs: &amp;mut Vec&lt;u8&gt;);
        /// TEST/DEV only
        /// PROD uses randomize inputs
        fn EvaluateWithPackmsgWithInputs(&amp;self, inputs: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;
        /// TEST/DEV only
        /// PROD is using the PACKMSG version
        fn EvaluateWithInputs(&amp;self, inputs: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;

        fn GetNbInputs(&amp;self) -&gt; usize;
        fn GetNbOutputs(&amp;self) -&gt; usize;
        fn GetWidth(&amp;self) -&gt; usize;
        fn GetHeight(&amp;self) -&gt; usize;
    }
}

/// We MUST impl Send+Sync b/c EvaluateWrapper is used as a Bevy's Resource
/// EvaluateWithPackmsg/etc use a &quot;const&quot; PGC so on that part we are thread safe
/// BUT EvaluateWithPackmsg in circuit_evaluate/src/rust_wrapper.cpp MAY NOT be thread safe
/// depending on where &quot;outputs&quot; are(eg NOT thread safe if a class field, thread safe if returning std::vector)
unsafe impl Send for ffi::EvaluateWrapper {}
unsafe impl Sync for ffi::EvaluateWrapper {}

pub struct MyRustAes {
    pub aes: Aes128,
}

pub fn encrypt_block(aes: &amp;MyRustAes, low: &amp;mut u64, high: &amp;mut u64) {
    // init &quot;block&quot; from &quot;high+low&quot;
    // TODO or better instead of &quot;high, low&quot; params: rewrite to accept a param like &quot;key: *const c_char&quot; and use reinterpret_cast(&amp;this) in block.h?
    let input_vec: Vec&lt;u8&gt; = if cfg!(target_endian = &quot;big&quot;) {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(low.to_be_bytes());
        v.extend(high.to_be_bytes());
        v
    } else {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(low.to_le_bytes());
        v.extend(high.to_le_bytes());
        v
    };

    let mut block: GenericArray&lt;u8, U16&gt; = GenericArray::clone_from_slice(input_vec.as_slice());

    aes.aes.encrypt_block(&amp;mut block);

    let low_arr: [u8; 8] = block.as_slice()[..8].try_into().expect(&quot;Wrong length&quot;);
    let high_arr: [u8; 8] = block.as_slice()[8..].try_into().expect(&quot;Wrong length&quot;);

    if cfg!(target_endian = &quot;big&quot;) {
        *low = u64::from_be_bytes(low_arr);
        *high = u64::from_be_bytes(high_arr);
    } else {
        *low = u64::from_le_bytes(low_arr);
        *high = u64::from_le_bytes(high_arr);
    }
}

fn init_aes(key_low: u64, key_high: u64) -&gt; Box&lt;MyRustAes&gt; {
    let key: Vec&lt;u8&gt; = if cfg!(target_endian = &quot;big&quot;) {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(key_low.to_be_bytes());
        v.extend(key_high.to_be_bytes());
        v
    } else {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(key_low.to_le_bytes());
        v.extend(key_high.to_le_bytes());
        v
    };

    Box::new(MyRustAes {
        aes: Aes128::new_from_slice(&amp;key).unwrap(),
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>low level C++ garbled circuits evaluator part</p>
<p><a href="https://github.com/Interstellar-Network/wallet-app/tree/master/shared/rust/circuit_evaluate/src/cpp">wallet-app/shared/rust/circuit_evaluate/src/cpp/</a></p>
<h3 id="renderer"><a class="header" href="#renderer">Renderer</a></h3>
<p>This is the layer in charge of writting the results of display circuits evaluation directly to the framebuffer through GPU shaders
<a href="https://github.com/Interstellar-Network/wallet-app/tree/master/shared/rust/renderer">wallet-app/shared/rust/renderer</a></p>
<p><code>setup.rs</code> is one of the most critical part of the renderer, responsible for the creation of textures in which renderer will display the result of circuits evaluation/execution with GPU shaders</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn setup_pinpad_textures(
    mut commands: Commands,
    mut images: ResMut&lt;Assets&lt;Image&gt;&gt;,
    mut texture_atlas: ResMut&lt;Assets&lt;TextureAtlas&gt;&gt;,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials_color: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    rects_pinpad: Res&lt;crate::RectsPinpad&gt;,
) {
    // TODO https://bevy-cheatbook.github.io/features/parent-child.html
    // circle is the parent, Texture is child

    /// WARNING it is assumed that the layout is one row of 10 &quot;cases&quot;
    let atlas_width = rects_pinpad.circuit_dimension[0];
    let atlas_height = rects_pinpad.circuit_dimension[1];

    // pinpad
    let atlas_handle = texture_atlas.add(TextureAtlas::from_grid(
        images.add(uv_debug_texture(atlas_width, atlas_height)),
        Vec2::new((atlas_width as f32) / 10., atlas_height as f32),
        10,
        1,
    ));
    // draw a sprite from the atlas
    for row in 0..rects_pinpad.nb_rows {
        for mut col in 0..rects_pinpad.nb_cols {
            // on index = 9, we want to draw in the BOTTOM CENTER; which is why we move &quot;col++&quot;
            // TODO proper index directly(ie without &quot;if&quot;): exclude lower left(cancel button) and lower right(done button)
            let index = col + row * rects_pinpad.nb_cols;
            if index == 9 {
                col = col + 1;
            } else if index &gt;= 10 {
                break;
            }

            let current_rect = &amp;rects_pinpad.rects[[row, col]];

            let center_x = current_rect.center()[0];
            let center_y = current_rect.center()[1];

            commands.spawn_bundle(SpriteSheetBundle {
                transform: Transform {
                    translation: Vec3::new(center_x, center_y, 1.0),
                    ..default()
                },
                sprite: TextureAtlasSprite {
                    index: index,
                    custom_size: Some(Vec2::new(
                        current_rect.width() / 2.0,
                        current_rect.height() / 2.0,
                    )),
                    color: rects_pinpad.text_color,
                    ..default()
                },
                texture_atlas: atlas_handle.clone(),
                ..default()
            });

            // circle_radius: max(width, height), that way it works even if change
            let circle_radius = (current_rect.width() / 2.0).max(current_rect.height() / 2.0);

            commands.spawn_bundle(MaterialMesh2dBundle {
                mesh: meshes.add(Circle::new(circle_radius).into()).into(),
                material: materials_color.add(rects_pinpad.circle_color.into()),
                transform: Transform::from_xyz(center_x, center_y, 0.0),
                ..default()
            });
        }
    }
}

/// Will draw the message texture at the given RectMessage
pub fn setup_message_texture(
    mut commands: Commands,
    mut images: ResMut&lt;Assets&lt;Image&gt;&gt;,
    rect_message: Res&lt;crate::RectMessage&gt;,
) {
    // Texture message = foreground
    commands.spawn_bundle(SpriteBundle {
        texture: images.add(uv_debug_texture(
            rect_message.circuit_dimension[0],
            rect_message.circuit_dimension[1],
        )),
        sprite: Sprite {
            custom_size: Some(Vec2::new(
                rect_message.rect.width(),
                rect_message.rect.height(),
            )),
            color: rect_message.text_color,
            ..default()
        },
        transform: Transform::from_xyz(
            // Sprite default to Anchor::Center which means x=0.0 will center it; and this also why &quot;rect.height() / 2.0&quot; and &quot;&quot;rect.width() / 2.0&quot;&quot;
            rect_message.rect.center()[0],
            rect_message.rect.center()[1],
            1.0,
        ),
        ..default()
    });
}

/// add_startup_system: Init TextureUpdateCallbackMessage/TextureUpdateCallbackPinpad
/// using the mod &quot;update_texture_utils&quot;
// TODO ideally we would want to pass the function all the way from init_app, to completely
// decouple renderer and &quot;circuit update&quot;
pub fn setup_texture_update_systems(
    mut texture_update_callback_message: ResMut&lt;TextureUpdateCallbackMessage&gt;,
    mut texture_update_callback_pinpad: ResMut&lt;TextureUpdateCallbackPinpad&gt;,
) {
    texture_update_callback_message.callback = Some(Box::new(
        crate::update_texture_utils::update_texture_data_message,
    ));
    texture_update_callback_pinpad.callback = Some(Box::new(
        crate::update_texture_utils::update_texture_data_pinpad,
    ));
}

/// NOTE: it will REPLACE the default shader used by all SpriteSheetBundle/SpriteBundle/etc
/// This shader is allows to us to use alpha as a mask
/// - when the channel is set, it will draw the given color(set in Sprite init)
/// - when channel is 0.0, it will be full transparent[rbga 0,0,0,0]
/// -&gt; ie we DO NOT want a background color; we want to &quot;draw only the foreground&quot;
///
/// ARCHIVE/ALTERNATIVE?
/// Based on https://github.com/bevyengine/bevy/blob/v0.7.0/examples/2d/sprite_manual.rs
/// but derive SpritePipeline instead of SpritePipeline
///
/// Allows to use a custom shader, with added uniform for colors
/// SpritePipeline only supports blending ONE color, but we want a behavior like
/// an ALPHA only texture(RED channel only in our case)
/// - if the channel is 1.0: draw the foreground color
/// - if the channel is 0.0: draw the background color
/// We do it this way b/c the &quot;circuit outputs&quot; are binary, so it simpler to have a
/// binary-like texture on the GPU side.
/// We could probably do it with a RGBA texture IFF the layout in memory is RRR...GGG...BBB...AAA
/// else it would means a sub-optimal buffer copy each frame instead of the direct
/// ~ memcopy(&quot;circuit outputs&quot;, &quot;texture&quot;)
///
/// -&gt; TODO? this fails b/c SpritePipeline* fields are private, which means we basically have to copy paste everything
/// in order to access them in &quot;queue_colored_sprites&quot;
//
// TODO can we find a way to override the shader only when needed
// see https://github.com/bevyengine/bevy/blob/main/crates/bevy_sprite/src/render/mod.rs for where SPRITE_SHADER_HANDLE is used
// cf colored_sprite_pipeline.rs
// NOTE: right now we use a DEFINE(let in wgsl) so both message and pinpad sprite WILL have the same text color...
pub fn setup_transparent_shader_for_sprites(
    mut shaders: ResMut&lt;Assets&lt;Shader&gt;&gt;,
    // mut pipeline_cache: ResMut&lt;bevy::render::render_resource::PipelineCache&gt;,
    // mut pipelines: ResMut&lt;
    //     bevy::render::render_resource::SpecializedRenderPipelines&lt;bevy::sprite::SpritePipeline&gt;,
    // &gt;,
    // mut sprite_pipeline: ResMut&lt;bevy::sprite::SpritePipeline&gt;,
    // msaa: Res&lt;Msaa&gt;,
    // theme: Res&lt;crate::Theme&gt;,
) {
    // cf https://github.com/bevyengine/bevy/blob/v0.7.0/crates/bevy_sprite/src/lib.rs
    // can we modify render/sprite.wgsl to do &quot;if background color, set alpha = 0.0, else draw color&quot;
    // TODO is there a way to override the shader for a specific Sprite?

    // let text_color_rgba = theme.text_color.as_rgba_f32();
    // let define_str = format!(
    //     &quot;let BACKGROUND_COLOR: vec4&lt;f32&gt; = vec4&lt;f32&gt;({:.5}, {:.5}, {:.5}, {:.5});&quot;,
    //     text_color_rgba[0], text_color_rgba[1], text_color_rgba[2], text_color_rgba[3]
    // );

    let shader_str = format!(&quot;{}&quot;, include_str!(&quot;../data/transparent_sprite.wgsl&quot;));

    let new_sprite_shader = Shader::from_wgsl(shader_str);
    shaders.set_untracked(bevy::sprite::SPRITE_SHADER_HANDLE, new_sprite_shader);

    // TODO?
    // pipeline_cache
    //     .get_render_pipeline_descriptor(bevy::render::render_resource::CachedRenderPipelineId(0))
    //     .fragment
    //     .unwrap()
    //     .shader_defs
    //     .push(&quot;other&quot;.to_string());
    //
    // cf /.../bevy_sprite-0.7.0/src/render/mod.rs around &quot;let colored_pipeline&quot;
    // let key = bevy::sprite::SpritePipelineKey::from_msaa_samples(msaa.samples);
    // let pipeline = pipelines.specialize(&amp;mut pipeline_cache, &amp;sprite_pipeline, key);
    // let colored_pipeline = pipelines.specialize(
    //     &amp;mut pipeline_cache,
    //     &amp;sprite_pipeline,
    //     key | bevy::sprite::SpritePipelineKey::COLORED,
    // );
}

// Creates a colorful test pattern
// https://github.com/bevyengine/bevy/blob/main/examples/3d/shapes.rs
fn uv_debug_texture(width: u32, height: u32) -&gt; Image {
    // : Vec&lt;u8&gt; = vec!
    // : &amp;[u8; 32] = &amp;
    let palette: Vec&lt;u8&gt; = vec![
        255, 102, 159, 255, 255, 159, 102, 255, 236, 255, 102, 255, 121, 255, 102, 255, 102, 255,
        198, 255, 102, 198, 255, 255, 121, 102, 255, 255, 236, 102, 255, 255,
    ];

    // let mut texture_data = vec![0; (width * height * TEXTURE_PIXEL_NB_BYTES).try_into().unwrap()];
    // for y in 0..height {
    //     let offset = width * y * TEXTURE_PIXEL_NB_BYTES;
    //     texture_data[offset..(offset + width * TEXTURE_PIXEL_NB_BYTES)].copy_from_slice(&amp;palette);
    //     palette.rotate_right(4);
    // }
    //
    // 4 because RGBA(or ARGB)
    let target_size = (width * height * TEXTURE_PIXEL_NB_BYTES) as usize;
    let mut texture_data = Vec::with_capacity(target_size);
    while texture_data.len() &lt; target_size {
        let start = texture_data.len();
        // end:
        // - try to append the whole &quot;palette&quot;(32 bytes)
        // - but DO NOT exceed target_size
        let end = std::cmp::min(target_size, start + palette.len());
        texture_data.extend(&amp;palette[0..(end - start)]);
    }
    assert!(texture_data.len() == target_size);

    Image::new_fill(
        Extent3d {
            width: width,
            height: height,
            depth_or_array_layers: 1,
        },
        wgpu::TextureDimension::D2,
        &amp;texture_data,
        // wgpu::TextureFormat::bevy_default(),
        wgpu::TextureFormat::R8Unorm,
    )
</code></pre></pre>
<h3 id="validation-screen"><a class="header" href="#validation-screen">Validation Screen</a></h3>
<p>High level screen in jetpack compose or swift UI to display the array of surface views generated directly by the GPU into the framebuffer with shaders.
This is just to illustrate that all the work is done by the lower level layers.</p>
<p><a href="https://github.com/Interstellar-Network/wallet-app/blob/master/androidApp/src/main/java/gg/interstellar/wallet/android/ui/TxPinpadScreen.kt">TxPinpadScreen.kt</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Mobile_App.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="HBMK.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Mobile_App.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="HBMK.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
