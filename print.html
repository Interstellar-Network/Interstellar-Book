<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interstellar Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="GCF.html"><strong aria-hidden="true">1.</strong> Garbled Circuit Factory - GCF</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="GC.html"><strong aria-hidden="true">1.1.</strong> Garbled Circuit Overview</a></li><li class="chapter-item expanded "><a href="VC-GC.html"><strong aria-hidden="true">1.2.</strong> Visual Cryptography Display</a></li><li class="chapter-item expanded "><a href="GCF_pipeline_detailed.html"><strong aria-hidden="true">1.3.</strong> Detailed Pipeline for Display Circuits</a></li><li class="chapter-item expanded "><a href="GCF_API.html"><strong aria-hidden="true">1.4.</strong> Garbled Circuit Factory APIs</a></li></ol></li><li class="chapter-item expanded "><a href="TTVP.html"><strong aria-hidden="true">2.</strong> Trusted Transaction Validation Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TAUI.html"><strong aria-hidden="true">2.1.</strong> Trusted Authentication & UI Layer</a></li><li class="chapter-item expanded "><a href="TTVP_detailed.html"><strong aria-hidden="true">2.2.</strong> TTVP detailed</a></li></ol></li><li class="chapter-item expanded "><a href="Mobile_Registry.html"><strong aria-hidden="true">3.</strong> Mobile Registry</a></li><li class="chapter-item expanded "><a href="Mobile_App.html"><strong aria-hidden="true">4.</strong> Mobile Wallet App</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TTVP_client.html"><strong aria-hidden="true">4.1.</strong> TTVP Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HBMK.html"><strong aria-hidden="true">4.1.1.</strong> Hardware-backed Mobile Key</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime_prerequisite.html"><strong aria-hidden="true">5.1.</strong> Runtime prerequisite</a></li><li class="chapter-item expanded "><a href="compilation_prerequisite.html"><strong aria-hidden="true">5.2.</strong> compilation prerequisite</a></li><li class="chapter-item expanded "><a href="M1.html"><strong aria-hidden="true">5.3.</strong> M1 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M1_demo_tutorial.html"><strong aria-hidden="true">5.3.1.</strong> M1 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="M2.html"><strong aria-hidden="true">5.4.</strong> M2 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M2_demo_tutorial.html"><strong aria-hidden="true">5.4.1.</strong> M2 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="M3.html"><strong aria-hidden="true">5.5.</strong> M3 Delivery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="M3_demo_tutorial.html"><strong aria-hidden="true">5.5.1.</strong> M3 Docker Demo Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="GCF_API_Test_Guide.html"><strong aria-hidden="true">5.6.</strong> GCF APIs Testing Guide</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Interstellar Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <picture>
  <source 
    srcset="fig/Interstellar-White-Text.png" 
    media="(prefers-color-scheme: dark)">
  <img src="fig/Interstellar-Black-Text.png">
</picture>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>“The blockchain ecosystem needs an easy to use interface with hardware wallet security to reach the mass market.”</p>
<p>The main pain points of non-custodial wallet solutions still are:</p>
<ul>
<li><strong>User experience</strong>  <a href="https://medium.com/@jlleleu/can-be-an-easy-to-set-up-wallet-an-efficient-customer-acquisition-tool-for-defi-players-8600812fe01e">Can an easy to set-up wallet be an efficient customer acquisition tool for DeFi players?</a></li>
<li><strong>Security</strong> <a href="https://medium.com/@jlleleu/are-cryptocurrency-wallets-more-at-risk-than-ever-cf1ce9725de7">Are cryptocurrency wallets more at risk than ever?</a> </li>
</ul>
<blockquote>
<p>We think that current wallet solutions slow down the DeFi adoption.</p>
</blockquote>
<p>Interstellar is a novel non-custodial peace of mind mobile wallet with a hardware security level. Based on a Substrate blockchain and SubstraTEE/IntegriTEE workers.</p>
<p><strong>We can now provide the same hardware security level as hardware wallets with only a mobile and a blockchain</strong></p>
<p><img src="./fig/Hardware_Mobile_Blockchain_Overview.png" alt="Hardware Mobile Blockchain Overview" /></p>
<p><strong>Thanks to Trusted User Interface TUI on mobile and Trusted Execution Environment on both mobile and blockchain nodes</strong></p>
<p>Because TUI is not yet avalaible on all mobile devices we use a Garbled Circuit/Visual Cryptography scheme which provides an alternative that will be complementary down the road to mitigate potential flaws in TUI.</p>
<p><img src="./fig/IPhone-Android-TUI-Overview.png" alt="IPhone Android TUI Overview" /></p>
<!-- ![Iphone-Android-TUI-White (1)](https://user-images.githubusercontent.com/4605611/145201585-5d106219-e51e-44d3-8c1b-95fe99e71455.png#gh-dark-mode-only)

![Iphone-Android-TUI-Black (1)](https://user-images.githubusercontent.com/4605611/145201886-30bafb07-fc1c-4dc0-acf9-f0e9f163fa66.png#gh-light-mode-only) -->
<h4 id="features"><a class="header" href="#features">Features:</a></h4>
<ul>
<li>
<p><strong>Hardware security Level</strong> - TEE on nodes and mobiles (incl. TUI), garbled circuits and visual cryptography secure interface</p>
</li>
<li>
<p><strong>Just download an app</strong> - no registration, PIN, password, passphrase, private key or any secret to store or remember</p>
</li>
<li>
<p><strong>Multichain Wallet</strong> - securely store and interact with native cryptocurrency coins and tokens from multiple blockchains</p>
</li>
<li>
<p><strong>Confirm a transaction with ONLY ONE SCREEN</strong> - no SMS to wait for, no additional 2FA app to use, no QR code to scan</p>
</li>
<li>
<p><strong>Up to 1,000,000 tps</strong> - no tps limit due to slow consensus, thanks to IntegriTEE layer 2 based on hardware enclave technology </p>
</li>
<li>
<p><strong>Social Recovery Service</strong> - leverages the existing Substrate pallet and a novel decentralized autonomous recovery service </p>
</li>
<li>
<p><strong>Features to securely send coins with social network messages (even to persons with no-wallet)</strong> - explained in <a href="https://medium.com/@jlleleu/can-be-an-easy-to-set-up-wallet-an-efficient-customer-acquisition-tool-for-defi-players-8600812fe01e">Can an easy to set-up wallet be an efficient customer acquisition tool for DeFi players?</a> </p>
</li>
</ul>
<h4 id="our-solution-is-designed-to-support-blockchain-and-defi-mass-market-adoption-with"><a class="header" href="#our-solution-is-designed-to-support-blockchain-and-defi-mass-market-adoption-with">Our solution is designed to support blockchain and DeFi mass market adoption with:</a></h4>
<ul>
<li><strong>A decentralized key &amp; asset management service</strong> where the user’s privates keys and signature programs are stored and executed in TEE nodes</li>
<li><strong>A decentralized Trusted Transaction Validation protocol</strong> that leverages TEE and TUI features on mobile, combined with One Time Garbled Circuits and Visual Cryptography to provide a <strong>Trusted Authentication and Trusted UI layer</strong> on user devices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoduction-to-garbled-circuit-factory-gcf"><a class="header" href="#intoduction-to-garbled-circuit-factory-gcf">Intoduction to Garbled Circuit Factory (GCF)</a></h1>
<p>The Garble Circuit Factory is the module in charge of building the Garbled Circuits (GC) used by the Interstellar infrastructure.</p>
<p>Following is a high level overview of the generic pipeline used to generate GC.</p>
<p><img src="./fig/GC-Pipeline-Overview.svg" alt="GC Pipeline Overview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbled-circuit-overview"><a class="header" href="#garbled-circuit-overview">Garbled Circuit Overview</a></h1>
<h2 id="basic-garbled-circuit-structure-overview"><a class="header" href="#basic-garbled-circuit-structure-overview">Basic Garbled Circuit structure overview</a></h2>
<p>A garbled circuit is a cryptographic obfuscation technique and a cryptographic algorithm that ensures computation privacy i.e. manages the protection of a boolean circuit that can be executed without leaking information. Neither the semantics of boolean operators (AND, OR, XOR, etc.) that make up the circuit nor the semantics of inputs and outputs of the circuit will be revealed to the attackers through reverse-engineering or brute force attacks.</p>
<p><img src="./fig/GC-Structure-Overview.png" alt="GC Structure Overview" /></p>
<ul>
<li>Inputs and outputs are Garbled Values i.e. 128 bits token indistinguishable from random with a secret semantic value of 0 or 1 only known by the nodes</li>
<li>Each boolean operator is implemented in the circuit by an encrypted truth table, decrypted by its respective Garbled Values inputs.</li>
</ul>
<p><a href="https://www.cs.fsu.edu/%7Etvhoang/thesis.pdf">Foundation of Garbled Circuits, Viet Tung Hoang, B.S.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-cryptography-display"><a class="header" href="#visual-cryptography-display">Visual Cryptography Display</a></h1>
<p>Garbled Circuit &amp; Visual Cryptography Screen</p>
<h2 id="garbled-circuits-output-frames"><a class="header" href="#garbled-circuits-output-frames">Garbled Circuits output frames</a></h2>
<p><img src="./fig/Visual-Cryptography-Technical-Overview.png" alt="Visual Cryptography Technical Overview" /></p>
<p>Those frames superspose on retinal eyes leveraging persistence of vision</p>
<h2 id="visual-cryptography"><a class="header" href="#visual-cryptography">Visual Cryptography</a></h2>
<p><img src="./fig/Visual_crypto_animation_demo.gif" alt="VC demo" /></p>
<h2 id="main-principles"><a class="header" href="#main-principles">Main principles</a></h2>
<p>We use a pre-computed One-Time Garbled Circuit to generate and output Visual Cryptography Shares at 60–120 frames/second on the device framebuffer.</p>
<p>Those visual cryptography shares do not superpose on the device screen but only in the user's eye. Thanks to the human Persistence of Vision ability: your eye and brain retain a visual impression for about 1/30 of a second (the exact time depends on the brightness of the image). </p>
<h2 id="security-consideration"><a class="header" href="#security-consideration">Security consideration</a></h2>
<p>The garbled circuit execution will manage the display of consecutive random frames. The result is that the execution of the circuit will not leak any secret information (passwords, on-time  codes or pin pad/keyboard topologies) securely embeded in the circuit. </p>
<p>This ensures that an attacker won't be able to obtain this secret information</p>
<ul>
<li>during the garbled circuit execution</li>
<li>neither with a simple screenshot, thanks to visual cryptography and persistence of vision</li>
</ul>
<p>As a consequence, it prevent the attacker to build and execute a fake User Interface quickly enough during the display session.
This scheme can resist current banking trojans with overlay capabilities but not targeted attacks.</p>
<p>However, it makes a fake UI attack, complexe and resource intensive enough to enable us to detect it during the transaction validation session. </p>
<p>This is the way we aim at resisting potential targeted attacks. Thanks to our proof of history of legitimate computation scheme, (roadmap/research in progress), based on a specific reusable Garbled Circuit evaluation.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<blockquote>
<p>We started by implementing a working solution that outputs visual cryptography shares. We then realized that it was a bit disturbing for the user and that a pure visual cryptography scheme is not crucial for our overall security model. We then decided to provide a more friendly solution for the user that is also more efficient especially regarding Garbled Circuit size.</p>
</blockquote>
<p>Although our circuits display screens at a pixel level to manage any type of images, fonts types, characters sizes and more. We decided to switch on a slightly different solution.</p>
<p>Let's go back to an old fashioned displays to explain it.</p>
<p><img src="./fig/GatesSegmentBlack.png" alt="GatesSegment" /></p>
<p>The Garbled Circuit can randomly output each:</p>
<ul>
<li>segments/sub segments</li>
<li>any group of pixels</li>
<li>or even single pixel</li>
</ul>
<p>of a frame with a probability of 1/n ( n &gt; 2)</p>
<h3 id="display-example"><a class="header" href="#display-example">Display example</a></h3>
<p><img src="./fig/Wallet-Superposition-Black-Background-Demo.png" alt="walletdemo" /></p>
<h3 id="simulations"><a class="header" href="#simulations">Simulations</a></h3>
<p>To fine tune the design of our circuits and provide realistic look and feel of the solution, we designed the following
<a href="https://www.interstellar.gg/simulation">Transaction validation screen simulations</a> based on <a href="https://github.com/psychopy/psychojs">PsychoJS library -  PsychoPy (github.com)</a> and <a href="https://www.psychopy.org/">PsychoPy neuroscience/psychophysic tools</a></p>
<h3 id="future-plans"><a class="header" href="#future-plans">Future plans</a></h3>
<p>At a later stage, we aim at reusing our pixel based visual cryptography implementation and/or <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.7421&amp;rep=rep1&amp;type=pdf">segment-based visual cryptography</a> to increase the complexity level of potential attacks and enable video recording proof scheme without disturbing the smooth user experience. </p>
<h3 id="research-lead"><a class="header" href="#research-lead">Research Lead</a></h3>
<p>Research lead is to leverage SRAM framebuffer speed 10-30x vs. DRAM to force the attacker to miss frames with a saturated GPU command queue filled with decoy and VC frames on high frequency displays.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="detailed-pipeline-for-display-circuits-production"><a class="header" href="#detailed-pipeline-for-display-circuits-production">Detailed Pipeline for Display Circuits Production</a></h1>
<p>This is the Garbled Circuits generation detailed pipeline for the Transaction Validation screen use case.</p>
<p>It illustrates the way Garbled Circuit Factory can be used with substrate OCWs for the production of the display garbled circuits used by Interstellar.</p>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<blockquote>
<p>The file types are mentioned for clarity and to allow matching with calling the executables (e.g. Yosys or ABC) manually, but in practice after [2] all is done in memory, and cached.</p>
</blockquote>
<p><strong>On the following schema, cached files are represented with red doted line</strong></p>
<blockquote>
<p><strong>The red arrow represents the command to lauch the circuit generation pipeline from OCW GCF</strong></p>
</blockquote>
<p><img src="./fig/GC-Pipeline-Detailed.svg" alt="GC Pipeline Detailed" /></p>
<p>Overview : </p>
<p><code>[1] Generate~</code> “segment2pixel.v” using internal code [using e.g. 7segs.png]</p>
<p><code>[2] Verilog  → .blif</code>: combine all Verilog(displaymain+xorexpand+rndswitch+segment2pixel) using Yosys</p>
<p><code>[3] .blif → .blif.blif </code>: optimization /synthesis : using ABC</p>
<p><code>[4] Parsing .blif → .skcd </code>: using internal code</p>
<p><code>[5] Garbling .skcd → .garbled</code>: using JustGarble</p>
<p><code>[6] Finalize/Serialize .garbled → .pgarbled</code>: Using internal code; allows for parallel eval of a Garbled Circuit</p>
<h3 id="1-generate-segment2pixelv"><a class="header" href="#1-generate-segment2pixelv">[1] Generate “segment2pixel.v”</a></h3>
<blockquote>
<p>This is the only file in the pipeline that needs to be regenerated when changing size/resolution. 
The rest (displaymain.v, xorexpand.v, and rndswitch.v) are static, and the size/resolution is handled by passing the appropriate “`define” to Yosys.</p>
</blockquote>
<p>This allows to cache the resulting .skcd of the whole pipeline (cf <code>CircuitPipeline::GenerateDisplaySkcd</code>) using <code>segment2pixel.v</code> <strong>content as cache key</strong>.</p>
<h4 id="segment2pixel-use-drawable-functions-to-create-the-verilog-circuit-based-on-7xsegspng-configuration-file"><a class="header" href="#segment2pixel-use-drawable-functions-to-create-the-verilog-circuit-based-on-7xsegspng-configuration-file">Segment2pixel use drawable functions to create the verilog circuit based on 7(x)segs.png (configuration file)</a></h4>
<p>7segs.png (or other) is parsed from an embedded resource into the executable, and prepared for later use (and some pre-computation is done based on the colors of the .png)</p>
<blockquote>
<p>We can use other files like 14segs.png to handle segment based visual cryptography down the road</p>
</blockquote>
<pre><code class="language-cpp  editable">namespace drawable {

IDrawableSegmentedDigitRelCoordsLocal::IDrawableSegmentedDigitRelCoordsLocal(
    DigitSegmentsType segments_type)
    : segments_type_(segments_type),
      nb_segments_per_digit_(GetDigitSegmentsTypeNbSegments(segments_type_)) {}

DigitSegmentsType IDrawableSegmentedDigitRelCoordsLocal::GetType() const {
  return segments_type_;
}

uint32_t IDrawableSegmentedDigitRelCoordsLocal::GetNbSegments() const {
  return nb_segments_per_digit_;
}

template &lt;typename DrawableWhereT&gt;
Drawable&lt;DrawableWhereT&gt;::Drawable(
    DrawableWhereT&amp;&amp; where_to_draw,
    const IDrawableSegmentedDigitRelCoordsLocal&amp; what_to_draw)
    : where_to_draw_(std::move(where_to_draw)), what_to_draw_(what_to_draw) {}

template &lt;typename DrawableWhereT&gt;
const IDrawableSegmentedDigitRelCoordsLocal&amp; Drawable&lt;DrawableWhereT&gt;::What()
    const {
  return what_to_draw_;
}

template &lt;typename DrawableWhereT&gt;
const DrawableWhereT&amp; Drawable&lt;DrawableWhereT&gt;::Where() const {
  return where_to_draw_;
}

/**
 * NOTE: try NOT to make this part too Verilog-specific because that way we can
 * write the output to a bitmap/png which is easier for dev/debug.
 * Technically this COULD directly return a map of some sort:
 * pixel(x1,y1) = segment0
 * pixel(x2,y2) = segment1
 * and assume the UNreturned pixel are background(ie NOT a SegmentID)
 */
template &lt;typename DrawableWhereT&gt;
std::vector&lt;SegmentID&gt; Draw(
    const std::vector&lt;drawable::Drawable&lt;DrawableWhereT&gt;&gt;&amp; drawables,
    u_int32_t width, u_int32_t height) {
  std::vector&lt;SegmentID&gt; img_seg_ids;
  img_seg_ids.reserve(width * height);

  // CAREFUL: DO NOT switch the order else the final garbled outputs will be
  // rotated 90 degrees. Not a catastrophe but not ideal.
  for (uint32_t y = 0; y &lt; height; ++y) {
    for (uint32_t x = 0; x &lt; width; ++x) {
      drawable::Point2DRelative rel_coords_world(
          static_cast&lt;float&gt;(x) / static_cast&lt;float&gt;(width),
          static_cast&lt;float&gt;(y) / static_cast&lt;float&gt;(height));

      // Find a drawable, if the rel_coords(ie the current pixel) is indeed on
      // one else it means it is background
      bool is_background = true;
      uint32_t offset_nb_segments = 0;
      for (const auto&amp; drawable : drawables) {
        if (drawable.Where().IsInBBox(rel_coords_world)) {
          is_background = false;

          auto rel_coords_local =
              drawable.Where().GetRelCoordsLocalFromRelCoordsWorld(
                  rel_coords_world);
          auto local_seg_id = drawable.What().GetSegmentID(rel_coords_local);
          if (local_seg_id != -1) {
            // REALLY IMPORTANT
            // MUST convert the local_seg_id(eg usually 0-6 for 7 segs)
            // to a global one UNIQUE in the final bitmap
            img_seg_ids.emplace_back(
                SegmentID(offset_nb_segments + local_seg_id));
          } else {
            // background (in the current drawable)
            img_seg_ids.emplace_back(-1);
          }

          // we COULD overwrite with another Drawable in case of overlap but
          // what is the point; we might as well stop processing
          break;
        }

        offset_nb_segments += drawable.What().GetNbSegments();
      }

      // background (in the global bitmap)
      if (is_background) {
        img_seg_ids.emplace_back(-1);
      }
    }
  }

  assert(img_seg_ids.size() == width * height &amp;&amp; &quot;Draw: missing pixels!&quot;);
  return img_seg_ids;
}

// &quot;explicit instantiation of all the types the template will be used with&quot;
template class Drawable&lt;RelativeBBox&gt;;
template std::vector&lt;SegmentID&gt; Draw&lt;RelativeBBox&gt;(
    const std::vector&lt;drawable::Drawable&lt;RelativeBBox&gt;&gt;&amp; drawables,
    u_int32_t width, u_int32_t height);

}  //   namespace drawable
</code></pre>
<p><code>Segments2Pixels::Segments2Pixels</code>: <a href="https://github.com/Interstellar-Network/lib_circuits/blob/main/src/segments2pixels/segments2pixels.cpp">lib_circuits/src/segments2pixels/segments2pixels.cpp:137</a></p>
<pre><code class="language-cpp editable">namespace interstellar {

template &lt;typename DrawableWhereT&gt;
Segments2Pixels&lt;DrawableWhereT&gt;::Segments2Pixels(
    uint32_t width, uint32_t height,
    const std::vector&lt;drawable::Drawable&lt;DrawableWhereT&gt;&gt;&amp; drawables)
    : width_(width), height_(height), drawables_(drawables) {
  uint32_t nb_digits = drawables_.size();

  // CHECK drawables MUST NOT be empty
  // We could return early instead of throwing but generating and then garbling
  // a circuit with no input does not really make sense.
  // Also it has never been tested so we would rather throw.
  if (drawables_.empty()) {
    throw std::logic_error(&quot;Segments2Pixels: drawables MUST NOT be empty&quot;);
  }

  // CHECK that all Drawable are the same class
  drawable::DigitSegmentsType segments_type = drawables_[0].What().GetType();
  uint32_t nb_segs_per_digit = drawables_[0].What().GetNbSegments();
  for (const auto&amp; drawable : drawables_) {
    if (drawable.What().GetType() != segments_type) {
      throw std::logic_error(
          &quot;Segments2Pixels: drawing different digits is not allowed&quot;);
    }
    nb_segments_ += drawable.What().GetNbSegments();
  }

  assert(nb_segments_ == nb_digits * nb_segs_per_digit &amp;&amp;
         &quot;nb_segments mismatch!&quot;);

  // RNDSIZE
  // TODO Check
  // Historically(before the support of variable otp_length), message had
  // RNDSIZE=9, and pinpad RNDSIZE=16
  // math.ceil(0.5 * math.sqrt(8 * otp_length * message_seg + 1) + 1)
  auto rndsize = static_cast&lt;unsigned int&gt;(
      std::max(std::ceil(0.5 * std::sqrt(8 * nb_segments_ + 1) + 1), 9.));
  config_ = {{&quot;WIDTH&quot;, width_},
             {&quot;HEIGHT&quot;, height_},
             {&quot;BITMAP_NB_SEGMENTS&quot;, nb_segments_},
             {&quot;RNDSIZE&quot;, rndsize},
             {&quot;NB_DIGITS&quot;, nb_digits},
             {&quot;NB_SEGS_PER_DIGIT&quot;, nb_segs_per_digit},
             {&quot;SEGMENTS_TYPE&quot;, static_cast&lt;uint32_t&gt;(segments_type)}};
}
</code></pre>
<p>Then <code>segment2pixel.v</code> VHDL file is generated:</p>
<p><code>Segments2Pixels::GenerateVerilog</code>: <a href="https://github.com/Interstellar-Network/lib_circuits/blob/main/src/segments2pixels/segments2pixels.cpp#L137"> lib_circuits/src/segments2pixels/segments2pixels.cpp:232</a></p>
<p>A “bitmap” is generated with the correct number of digits at the correct positions [in relative coords]
E.g. 2-4 digits in the center of the “message window”, and 10 digits vertically oriented for the “pinpad window”
If there is an in-memory .skcd cached for this particular “segment2pixel.v” it is returned and that part is done</p>
<pre><code class="language-cpp editable">template &lt;typename DrawableWhereT&gt;
std::string Segments2Pixels&lt;DrawableWhereT&gt;::GenerateVerilog() const {
  // Generate the complete bitmap, then compute the SegmentID for each pixel
  // Previously it was done is the ctor then stored in class member but it is
  // only used here so no point in doing that
  std::vector&lt;drawable::SegmentID&gt; bitmap_seg_ids =
      Draw(drawables_, width_, height_);

  std::vector&lt;utils::RLE_int8_t&gt; bitmap_seg_ids_rle =
      utils::compress_rle(bitmap_seg_ids);

  std::string verilog_buf;
  unsigned int nb_inputs = nb_segments_ - 1,
               nb_outputs = (width_ * height_) - 1;

  // without reserve : 1657472 - 1771623 (ns)
  // with reserve : 1250652 - 1356733 (ns)
  // Now in the .v, ranges are encoded as eg: assign p[75295:75287] = 0;
  // So we really do not need much memory.
  unsigned int nb_pixels = width_ * height_;
  size_t size_to_reserve =
      ((nb_pixels * strlen(&quot;assign p[000000] = s[0000];\n&quot;)) / 5) + 1000;
  verilog_buf.reserve(size_to_reserve);

  verilog_buf += &quot;// module to convert segments into an image bitmap\n&quot;;
  verilog_buf +=
      &quot;// generated by lib_circuits/src/segments2pixels/segments2pixels.cpp\n&quot;;
  verilog_buf += &quot;// (c) Interstellar\n\n&quot;;

  verilog_buf += &quot;module segment2pixel(s, p);  // convert segments to pixels\n&quot;;
  // TODO
  verilog_buf +=
      fmt::format(&quot;input [{:d}:0] s; // segments to display\n&quot;, nb_inputs);
  verilog_buf +=
      fmt::format(&quot;output [{:d}:0] p;  // pixels output\n&quot;, nb_outputs);

  // TODO use absl or fmtlib
  size_t pixels_counter = 0;
  for (const auto&amp; it : bitmap_seg_ids_rle) {
    // NOTE: bitmap_seg_ids_rle is RLE encoded
    // - OFF segment(seg_id==-1):   &quot;assign p[7680:0] = 0;&quot;
    // - ON segment(eg seg_id=16):  &quot;assign p[17855:17854] = s[16];&quot;
    auto seg_id = it.value;
    auto len = it.size;
    if (seg_id == -1) {
      // NOTE: range inverted! written as eg [7680:0] not [0:7680]
      verilog_buf += &quot;assign p[&quot;;
      verilog_buf += fmt::format_int(pixels_counter + len - 1).str();
      verilog_buf += &quot;:&quot;;
      verilog_buf += fmt::format_int(pixels_counter).str();
      verilog_buf += &quot;] = &quot;;
      verilog_buf += &quot;0;\n&quot;;
    } else {
      // When a valid seg_id, we CAN NOT write eg &quot;assign p[7456:7412] = s[14];&quot;
      // This is NOT valid verilog, apparently
      // verilator --lint-only: &quot;Operator ASSIGNW expects 47 bits on the Assign
      // RHS, but Assign RHS's SEL generates 1 bits.&quot;
      for (uint32_t j = pixels_counter; j &lt; pixels_counter + len; ++j) {
        verilog_buf += &quot;assign p[&quot;;
        verilog_buf += fmt::format_int(j).str();
        verilog_buf += &quot;] = &quot;;
        verilog_buf += &quot;s[&quot;;
        verilog_buf += fmt::format_int(seg_id).str();
        verilog_buf += &quot;];\n&quot;;
      }
    }
    pixels_counter += len;
  }

  verilog_buf += &quot;endmodule&quot;;

  return verilog_buf;
}

/**
 * display-main.v and others expect eg:
 *
  `define WIDTH 56
  `define HEIGHT 24
  `define RNDSIZE 9
  `define BITMAP_NB_SEGMENTS 28
 */
template &lt;typename DrawableWhereT&gt;
std::string Segments2Pixels&lt;DrawableWhereT&gt;::GetDefines() const {
  auto verilog_defines = verilog::Defines();
  // NOTE: probably NOT all the config keys are needed on the Verilog side
  for (auto const&amp; [key, val] : config_) {
    verilog_defines.AddDefine(key, val);
  }

  return verilog_defines.GetDefinesVerilog();
}

/**
 * We could DRY with GetDefines but most of the keys in config are NOT needed on
 * the Verilog side.
 */
template &lt;typename DrawableWhereT&gt;
const absl::flat_hash_map&lt;std::string, uint32_t&gt;&amp;
Segments2Pixels&lt;DrawableWhereT&gt;::GetConfig() const {
  return config_;
}

// &quot;explicit instantiation of all the types the template will be used with&quot;
template class Segments2Pixels&lt;drawable::RelativeBBox&gt;;

}  // namespace interstellar
</code></pre>
<h3 id="234-generate-skcd"><a class="header" href="#234-generate-skcd">[2][3][4] Generate .skcd</a></h3>
<p>The big steps are self-explanatory (pretty much just calling ABC or Yosys, and handling/parsing the results or errors; most of the business logic is in step [1]) :</p>
<p><code>CircuitPipeline::GenerateSkcd</code>: <a href="https://github.com/Interstellar-Network/lib_circuits/blob/main/src/circuit_lib.cpp#L19">lib_circuits/src/circuit_lib.cpp:19</a></p>
<pre><code class="language-cpp  editable">amespace interstellar {

namespace circuits {

// TODO how to handle InitGoogleLogging ?

void GenerateSkcd(boost::filesystem::path skcd_output_path,
                  const std::vector&lt;std::string_view&gt; &amp;verilog_inputs_paths,
                  const utils::TempDir &amp;tmp_dir) {
  auto blif_parser = GenerateBlifBlif(verilog_inputs_paths, tmp_dir);

  interstellar::skcd::WriteToFile(skcd_output_path, blif_parser);
}

std::string GenerateSkcd(
    const std::vector&lt;std::string_view&gt; &amp;verilog_inputs_paths,
    const utils::TempDir &amp;tmp_dir,
    absl::flat_hash_map&lt;std::string, uint32_t&gt; &amp;&amp;config) {
  auto blif_parser =
      GenerateBlifBlif(verilog_inputs_paths, tmp_dir, std::move(config));

  return interstellar::skcd::Serialize(blif_parser);
}

/**
 * [internal]
 */
void GenerateSkcd(boost::filesystem::path skcd_output_path,
                  const std::vector&lt;std::string_view&gt; &amp;verilog_inputs_paths) {
  auto tmp_dir = utils::TempDir();
  auto blif_parser = GenerateBlifBlif(verilog_inputs_paths, tmp_dir);

  interstellar::skcd::WriteToFile(skcd_output_path, blif_parser);
}

/**
 * [internal]
 */
std::string GenerateSkcd(
    const std::vector&lt;std::string_view&gt; &amp;verilog_inputs_paths,
    absl::flat_hash_map&lt;std::string, uint32_t&gt; &amp;&amp;config) {
  auto tmp_dir = utils::TempDir();
  auto blif_parser =
      GenerateBlifBlif(verilog_inputs_paths, tmp_dir, std::move(config));

  return interstellar::skcd::Serialize(blif_parser);
}

/**
 * IMPORTANT: used by api_circuits
 */
std::string GenerateSkcd(
    const std::vector&lt;std::string_view&gt; &amp;verilog_inputs_paths) {
  auto tmp_dir = utils::TempDir();
  auto blif_parser = GenerateBlifBlif(verilog_inputs_paths, tmp_dir);

  return interstellar::skcd::Serialize(blif_parser);
}

</code></pre>
<p>If there is no cached .skcd for the step [1], one is generated with 
<code>CircuitPipeline::GenerateDisplaySkcd</code>: <a href="https://github.com/Interstellar-Network/lib_circuits/blob/main/src/circuit_lib.cpp#L56">lib_circuits/src/circuit_lib.cpp:56</a></p>
<pre><code class="language-cpp  editable">void GenerateDisplaySkcd(
    boost::filesystem::path skcd_output_path, u_int32_t width, u_int32_t height,
    circuits::DisplayDigitType digit_type,
    std::vector&lt;std::tuple&lt;float, float, float, float&gt;&gt; &amp;&amp;digits_bboxes) {
  auto result_skcd_buf =
      GenerateDisplaySkcd(width, height, digit_type, std::move(digits_bboxes));

  utils::WriteToFile(skcd_output_path, result_skcd_buf);
}

std::string GenerateDisplaySkcd(
    u_int32_t width, u_int32_t height, DisplayDigitType digit_type,
    std::vector&lt;std::tuple&lt;float, float, float, float&gt;&gt; &amp;&amp;digits_bboxes) {
  auto tmp_dir = utils::TempDir();

  const auto &amp;what_to_draw = GetDrawableFromDigitType(digit_type);
  std::vector&lt;drawable::Drawable&lt;drawable::RelativeBBox&gt;&gt; drawables;
  for (auto &amp;&amp;digit_bbox : digits_bboxes) {
    drawables.emplace_back(
        drawable::RelativeBBox(std::get&lt;0&gt;(digit_bbox), std::get&lt;1&gt;(digit_bbox),
                               std::get&lt;2&gt;(digit_bbox),
                               std::get&lt;3&gt;(digit_bbox)),
        what_to_draw);
  }

  // [1] generate Verilog segments2pixels.v
  auto segments2pixels = Segments2Pixels(width, height, drawables);
  auto segments2pixels_v_str = segments2pixels.GenerateVerilog();
  auto config = segments2pixels.GetConfig();

  // write this to segments2pixels.v (in the temp dir)
  // because Yosys only handles files, not buffers
  auto segments2pixels_v_path = tmp_dir.GetPath() / &quot;segments2pixels.v&quot;;
  utils::WriteToFile(segments2pixels_v_path, segments2pixels_v_str);

  auto defines_v_str = segments2pixels.GetDefines();
  // write this to defines.v (in the temp dir)
  // because Yosys only handles files, not buffers
  auto defines_v_path = tmp_dir.GetPath() / &quot;defines.v&quot;;
  utils::WriteToFile(defines_v_path, defines_v_str);

  std::string result_skcd_buf = GenerateSkcd(
      {
          defines_v_path.generic_string(),
          segments2pixels_v_path.generic_string(),
          absl::StrCat(interstellar::data_dir, &quot;/verilog/rndswitch.v&quot;),
          absl::StrCat(interstellar::data_dir, &quot;/verilog/xorexpand.v&quot;),
          absl::StrCat(interstellar::data_dir, &quot;/verilog/display-main.v&quot;),
      },
      std::move(config));

  return result_skcd_buf;
}

}  // namespace circuits
</code></pre>
<h3 id="56-garbling"><a class="header" href="#56-garbling">[5][6] Garbling</a></h3>
<p>Pretty straitforward call to <code>lib_garble</code> library</p>
<p><code>ParallelGarbledCircuit GarbleSkcd</code>: <a href="https://github.com/Interstellar-Network/lib_garble/blob/main/src/parallel_garbled_circuit/parallel_garbled_circuit.cpp">lib_garble/src/justgarble/garble_helper.cpp:16</a></p>
<blockquote>
<p>This part is related to the management of display circuit OTP related to M2/M3</p>
</blockquote>
<p>Technically garbling + “stripping” (i.e. generating the “pre-packmsg”).
This is at this step that the pinpad/OTP randomness is introduced, i.e. the .skcd generated at the previous step CAN/SHOULD be reused (and it is) all the time (i.e. it is always reused, except when changing size or resolution).</p>
<p>We can manage 2 modes: on the fly generation and pre-computation of randomized circuits ( with random pinpad and OTP) with whithout transaction message.
The second mode will use “stripped circuits” sent to a device ahead of time and the “pre-packmsg” is stored in the DB.
Then when creating a transaction, the “pre-packmsg” is used to generate the correct “packmsg” with the desired transaction  message (e.g. “Do you authorize sending X BTC to Y address”), and then send it to the Device.
The Device then combines the “packmsg” and the “stripped circuits” and proceed to evaluate the circuits (= generating the final bitmap, one for each frame at the target 60+ FPS).</p>
<p>Regarding Transaction Validation displays, sending the circuits ahead of time is no mandatory (i.e. the generation is fast enough, and the size small enough to be able to get them on the spot even on a mobile) although this feature can be used in some specific cases and for other use cases.</p>
<h2 id="circuit-pipeline-api"><a class="header" href="#circuit-pipeline-api">Circuit Pipeline API</a></h2>
<p>We have chosen a  gRPC implementation mainly because  there is no no_std HTTP2 client in Rust, although there is a no_std Protobuf libs out there <a href="https://github.com/tokio-rs/prost/blob/978fb03f05f9927b43d6d402044f9fb41a9addb3/README.md#using-prost-in-a-no_std-crate">in the tokio framework</a> 
and we use tokio/tonic also compliant with HTTP1 to comunicate with OCWs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbled-cicuit-factory-apis"><a class="header" href="#garbled-cicuit-factory-apis">Garbled Cicuit Factory APIs</a></h1>
<p>Description of the APIs called from substrate modules to manage circuits production. Those APis are pretty generic and can be adapted to different types of circuit production.</p>
<blockquote>
<p><a href="https://ipfs.io/">IPFS</a> is used by the external GCF service for the storage of both configuration files and produced garbled circuits. Although, for now only ipfs hash/cid are used in the GCF substrate modules. At a later stage we could include substrate ipfs solutions like <a href="https://rs-ipfs.github.io/offchain-ipfs-manual/">OCW ipfs</a> to deal with other use cases e.g Secure Multi Party Computation. In that case pre-computed Garbled Circuit could be loaded from ipfs to be evaluated within a pallet module to manage an SMPC protocol with others parties.</p>
</blockquote>
<h2 id="flowchart-and--substrate-gcf-pallets"><a class="header" href="#flowchart-and--substrate-gcf-pallets">Flowchart and  substrate GCF pallets</a></h2>
<p><img src="./fig/GCF-Flowchart-Substrate-Pallets.svg" alt="GCF Flowchart Substrate Pallets" /></p>
<h2 id="gcf-apis"><a class="header" href="#gcf-apis">GCF APIs</a></h2>
<p>This is a list of the APIs used in substrate framework to pilot the generation of the Garbled Circuits required  by the Interstellar infrastructure.</p>
<h3 id="launh-circuit-generation-from-ocw-on-gcf-external-service"><a class="header" href="#launh-circuit-generation-from-ocw-on-gcf-external-service">Launh circuit generation from OCW on GCF (external service)</a></h3>
<p><code>generate_circuit</code>: <a href="https://github.com/Interstellar-Network/api_circuits/blob/main/src/circuits_routes.rs#L61">api_circuits/src/circuit_routes.rs:61</a></p>
<p><code>generate_garble</code> : <a href="https://github.com/Interstellar-Network/api_garble/blob/main/src/garble_routes.rs#L68">api_garble/src/garble_routes,rs:68</a></p>
<p><code>Request</code>   : start the circuit(s) generation with hash/cid  of master files + parameter related to circuit production e.g size/resolution of display circuits</p>
<p><code>Response</code>  : get hash/cid of the circuit on ipfs</p>
<p><code>Status</code>    : circuit production state</p>
<h4 id="circuit_routers---generation-of--display-circuit"><a class="header" href="#circuit_routers---generation-of--display-circuit">circuit_route.rs - generation of  display circuit</a></h4>
<pre><pre class="playground"><code class="language-rust editable">#[tonic::async_trait]
impl SkcdApi for SkcdApiServerImpl {
    async fn generate_skcd_display(
        &amp;self,
        request: Request&lt;SkcdDisplayRequest&gt;,
    ) -&gt; Result&lt;Response&lt;SkcdDisplayReply&gt;, Status&gt; {
        log::info!(
            &quot;generate_skcd_display request from {:?}&quot;,
            request.remote_addr()
        );
        let width = request.get_ref().width;
        let height = request.get_ref().height;

        // TODO class member/Trait for &quot;lib_circuits_wrapper::ffi::new_circuit_gen_wrapper()&quot;
        let lib_circuits_wrapper = tokio::task::spawn_blocking(move || {
            let wrapper = lib_circuits_wrapper::ffi::new_circuit_gen_wrapper();

            let skcd_pb_buf = wrapper.GenerateDisplaySkcd(width, height);

            skcd_pb_buf
        })
        .await
        .unwrap();

        let data = Cursor::new(lib_circuits_wrapper);

        // TODO error handling, or at least logging
        let ipfs_result = self.ipfs_client().add(data).await.unwrap();

        let reply = SkcdDisplayReply {
            skcd_cid: format!(&quot;{}&quot;, ipfs_result.hash),
        };

        Ok(Response::new(reply))
    }
</code></pre></pre>
<h4 id="generation-of-generic-circuits"><a class="header" href="#generation-of-generic-circuits">generation of generic circuits:</a></h4>
<pre><pre class="playground"><code class="language-rust editable">async fn generate_skcd_generic_from_ipfs(
        &amp;self,
        request: Request&lt;SkcdGenericFromIpfsRequest&gt;,
    ) -&gt; Result&lt;Response&lt;SkcdGenericFromIpfsReply&gt;, Status&gt; {
        log::info!(
            &quot;generate_skcd_generic_from_ipfs request from {:?}&quot;,
            request.remote_addr()
        );

        let verilog_cid = &amp;request.get_ref().verilog_cid;

        // get the Verilog (.v) from IPFS
        // DO NOT use dag_get if the file was &quot;add&quot;
        // The returned bytes would be eg
        // {&quot;Data&quot;:{&quot;/&quot;:{&quot;bytes&quot;:&quot;CAISjgQvL....ZfYWRkGI4E&quot;}},&quot;Links&quot;:[]}
        // let verilog_buf = self
        //     .ipfs_client()
        //     .dag_get(&amp;verilog_cid)
        //     .map_ok(|chunk| chunk.to_vec())
        //     .try_concat()
        //     .await
        //     .unwrap();
        let verilog_buf = self
            .ipfs_client()
            .cat(&amp;verilog_cid)
            .map_ok(|chunk| chunk.to_vec())
            .try_concat()
            .await
            .unwrap();

        // write the buffer to a file in /tmp
        // yosys/abc REQUIRE file b/c they are basically cli
        // so either write it on Rust side, or send as std::string to C++ and write it there
        let tmp_dir = Builder::new()
            .prefix(&quot;interstellar-circuit_routes-generate_skcd_generic_from_ipfs&quot;)
            .tempdir()
            .unwrap();
        let verilog_file_path = tmp_dir.path().join(&quot;input.v&quot;);
        std::fs::write(&amp;verilog_file_path, verilog_buf).expect(&quot;could not write&quot;);

        // TODO class member/Trait for &quot;lib_circuits_wrapper::ffi::new_circuit_gen_wrapper()&quot;
        let lib_circuits_wrapper = tokio::task::spawn_blocking(move || {
            let wrapper = lib_circuits_wrapper::ffi::new_circuit_gen_wrapper();

            let skcd_pb_buf =
                wrapper.GenerateGenericSkcd(verilog_file_path.as_os_str().to_str().unwrap());

            skcd_pb_buf
        })
        .await
        .unwrap();

        let data = Cursor::new(lib_circuits_wrapper);

        // TODO error handling, or at least logging
        let ipfs_result = self.ipfs_client().add(data).await.unwrap();

        let reply = SkcdGenericFromIpfsReply {
            skcd_cid: format!(&quot;{}&quot;, ipfs_result.hash),
        };

        Ok(Response::new(reply))
    }
}
</code></pre></pre>
<h4 id="generation-of-garbled-circuits"><a class="header" href="#generation-of-garbled-circuits">Generation of garbled circuits</a></h4>
<p>garble_route.rs</p>
<pre><pre class="playground"><code class="language-rust editable">#[tonic::async_trait]
impl GarbleApi for GarbleApiServerImpl {
    async fn garble_ipfs(
        &amp;self,
        request: Request&lt;GarbleIpfsRequest&gt;,
    ) -&gt; Result&lt;Response&lt;GarbleIpfsReply&gt;, Status&gt; {
        log::info!(&quot;Got a request from {:?}&quot;, request.remote_addr());
        let skcd_cid = &amp;request.get_ref().skcd_cid;

        // get the (.skcd) from IPFS
        // DO NOT use dag_get if the file was &quot;add&quot;
        // The returned bytes would be eg
        // {&quot;Data&quot;:{&quot;/&quot;:{&quot;bytes&quot;:&quot;CAISjgQvL....ZfYWRkGI4E&quot;}},&quot;Links&quot;:[]}
        // let skcd_buf = self
        //     .ipfs_client()
        //     .dag_get(&amp;skcd_cid)
        //     .map_ok(|chunk| chunk.to_vec())
        //     .try_concat()
        //     .await
        //     .unwrap();
        let skcd_buf = self
            .ipfs_client()
            .cat(&amp;skcd_cid)
            .map_ok(|chunk| chunk.to_vec())
            .try_concat()
            .await
            .unwrap();

        let tmp_dir = Builder::new()
            .prefix(&quot;interstellar-garble_routes-garble_ipfs&quot;)
            .tempdir()
            .unwrap();

        // write the data from IPFS to a temp file
        let skcd_input_path = tmp_dir.path().join(&quot;input.skcd.pb.bin&quot;);
        std::fs::write(&amp;skcd_input_path, skcd_buf).expect(&quot;could not write to skcd_input_path&quot;);

        // TODO class member/Trait for &quot;lib_garble_wrapper::ffi::new_garble_wrapper()&quot;
        let lib_garble_wrapper = tokio::task::spawn_blocking(move || {
            let wrapper = lib_garble_wrapper::ffi::new_garble_wrapper();

            // TODO make the C++ API return a buffer?
            let buf: Vec&lt;u8&gt; =
                wrapper.GarbleSkcdToBuffer(skcd_input_path.as_os_str().to_str().unwrap());

            buf
        })
        .await
        .unwrap();

        let data = Cursor::new(lib_garble_wrapper);

        // TODO error handling, or at least logging
        let ipfs_result = self.ipfs_client().add(data).await.unwrap();

        let reply = GarbleIpfsReply {
            pgarbled_cid: format!(&quot;{}&quot;, ipfs_result.hash),
        };

        Ok(Response::new(reply))
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-transaction-validation-protocol"><a class="header" href="#trusted-transaction-validation-protocol">Trusted Transaction Validation Protocol</a></h1>
<p>The purpose of the Trusted Transaction Validation Protocol is to provide a decentralized feature managed by a blockchain to authenticate and validate a transaction in a higly secure but frictionless way.</p>
<h2 id="trusted-transaction-validation-protocol-architecture---ttvp"><a class="header" href="#trusted-transaction-validation-protocol-architecture---ttvp">Trusted Transaction Validation Protocol architecture - TTVP</a></h2>
<p>The following schema shows the main components of Interstellar blockchain including the modules related to Trusted Transaction Validation protocol. It also includes future roadmap modules (briefly described)</p>
<p><img src="./fig/TTV_overview_dark.svg" alt="TTVP overview" /></p>
<h2 id="high-level-components-related-to-ttvp-in-interstellar-blockchain"><a class="header" href="#high-level-components-related-to-ttvp-in-interstellar-blockchain">High level components related to TTVP in Interstellar blockchain</a></h2>
<p>Those modules are based on Parity Substrate nodes and IntegriTEE workers.</p>
<h3 id="secure-ui-layer---transaction-screen-management"><a class="header" href="#secure-ui-layer---transaction-screen-management">Secure UI Layer - Transaction Screen Management</a></h3>
<p>The mobile transaction screen is managed with Garbled Circuits that are computed on TEE nodes and provisioned on the mobile by the nodes. The one-time code secret and keypad topology cannot be accessed during Garbled Circuit execution to display the Visual Cryptography secret frames that appears only in the users' eyes.  Thanks to persistence of vision. (cf <a href="./VC-GC.html">Visual Cryptography Display</a> and <a href="./TAUI.html">Trusted Authentication and User Interface</a>)</p>
<h3 id="mobile-trusted-authentication---mobile-key-management"><a class="header" href="#mobile-trusted-authentication---mobile-key-management">Mobile Trusted Authentication - Mobile Key Management</a></h3>
<p>A Public/Private key pair is generated in the mobile Hardware Enclave. The private key is not accessible by anyone, even when the device is rooted. The signature is only triggered with the user's biometrics (also managed with TEE).
The public Key is sent to the nodes and managed in the Mobile TEE registry (described below)</p>
<p>Actually we replace the wallet private keys by a TEE protected mobile private key. This protected key act as a proxy to all the keys owned by the user.</p>
<blockquote>
<p>It is securely tied to the user account. The wallet private keys associated with the user's assets are managed in the blockchain hardware enclave TEE nodes in <code>Trusted Keys and Asset Management &amp; Signers</code> module.</p>
</blockquote>
<p>In order to prevent potential attacks on hardware enclaves down the road, we will also use at later stage Multi Party Computation and especially Threshold Signature Scheme.</p>
<h3 id="mobile-tee-registry-pallet"><a class="header" href="#mobile-tee-registry-pallet">Mobile TEE registry pallet</a></h3>
<p>The <a href="./Mobile_Registry.html">substrate module</a> in charge of mobile device public key registration and mobile device management. </p>
<h4 id="attestation-management-roadmap"><a class="header" href="#attestation-management-roadmap">Attestation management (roadmap)</a></h4>
<p><a href="https://source.android.com/security/keystore/attestation">Key and ID Attestation  |  Android Open source project</a></p>
<p><a href="https://stackoverflow.com/questions/61225795/how-to-check-whether-android-phone-supports-tee/64422042#64422042">How to check whether Android phone supports TEE- Stack Overflow</a></p>
<h4 id="behavioral-biometric-roadmap"><a class="header" href="#behavioral-biometric-roadmap">Behavioral Biometric (roadmap)</a></h4>
<p>Each user has a unique typing pattern for a sequence of digits on a keypad. If a bad actor tries to replicate this pattern, it will be detected with a 98% success rate. This feature will be managed by TEE nodes with Machine Learnings classification models based on secret touch screen position inputs received by the nodes and their related authenticated timestamps.</p>
<p><a href="https://www.research.manchester.ac.uk/portal/files/159168194/FULL_TEXT.PDF">TOUCH DYNAMICS BIOMETRICS TO ENHANCE AUTHENTICATION ON MOBILE DEVICES</a></p>
<h4 id="ongoing-research-roadmap"><a class="header" href="#ongoing-research-roadmap">Ongoing Research (roadmap)</a></h4>
<p>Garbled circuits to generate proof of history of legitimate computation schemes to detect malware attacks to compromise the UI i.e. the building and execution of a fake User Interface by the attackers. (cf <code>Malware Detection</code> module in the mobile device)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-authentification-and-ui-layer"><a class="header" href="#trusted-authentification-and-ui-layer">Trusted Authentification and UI Layer</a></h1>
<p>Following a schema illustrating how the trusted authentication and transaction validation is managed.</p>
<p><img src="./fig/TV-GC_evaluator.svg" alt="TV-GC_evaluator" /></p>
<h2 id="1-the-mobile-received-a-transaction-to-validate"><a class="header" href="#1-the-mobile-received-a-transaction-to-validate">1 The mobile received a transaction to validate</a></h2>
<p>For each transaction to validate, a one time program i.e. garbled circuit is received and executed by the garbled circuit evaluator on the mobile.</p>
<h2 id="2-user-input"><a class="header" href="#2-user-input">2 User input</a></h2>
<p>Then the user inputs on the randomized keypad the one time code he see on the screen: 256 in this example.
P1(x1,y1), P2(x2,y2), P3(x3,y3) are the inputs positions matching 2,5,6 on the one time random keypad.</p>
<h2 id="3-signature-of-user-input"><a class="header" href="#3-signature-of-user-input">3 Signature of user input</a></h2>
<p>Fingerprint and/or facial recognization trigger the signature
of the user inputs with mobile private key stored in TEE.
Then the signed random position i.e. P1, P2, P3 are sent to the nodes to be verified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-transaction-validation-protocol-detailed"><a class="header" href="#trusted-transaction-validation-protocol-detailed">Trusted Transaction Validation Protocol Detailed</a></h1>
<h2 id="transaction-validation-management-modules-and-flowchart"><a class="header" href="#transaction-validation-management-modules-and-flowchart">Transaction validation management modules and flowchart</a></h2>
<p><img src="./fig/Transaction_Validation_Module.svg" alt="Transaction Validation Module" /></p>
<h2 id="tx-payload-req"><a class="header" href="#tx-payload-req">TX Payload Req</a></h2>
<p>Each time a transaction validation is required, a request is sent to the nodes. This request includes an operation message including transaction parameter: amount, destination address wallet.</p>
<h2 id="tx-validation-req"><a class="header" href="#tx-validation-req">TX Validation Req</a></h2>
<p>Upon reception of the previous message the node compute a garbled circuit program to oversee displaying of each pixel on the user's device's screen. This one time program that includes  transaction parameters, a one time code and a randomized keypad is sent to the owner’s wallet mobile app.</p>
<h2 id="tx-validation-resp"><a class="header" href="#tx-validation-resp">TX Validation Resp</a></h2>
<p>When the client's device receives the garbled circuit, it evaluates the circuit to display the keypad and the transaction message with a one-time code for validation. Once the transaction screen appears on the device, the user will type the one-time code displayed, on the random keypad. The response message (randomized keypad position) is then signed and sent to the nodes for validation. The wallet owner’s fingerprint and/or facial recognition is used to authenticate the user’s presence and triggers the signature of the message with the user’s mobile private key in the hardware enclave.</p>
<h2 id="the-node-receives-tx-resp"><a class="header" href="#the-node-receives-tx-resp">The node receives TX Resp</a></h2>
<p>It then uses the mobile public key provided by the mobile registry pallet to verify that the randomized position typed by the wallet owner comes from his device and that the user was present at that time. This process ensures that even if a legit garbled circuit is stolen during the transaction session, it cannot be used by another device through a man in the middle attack to validate the transaction. The node then checks if the one time code is valid to trigger the signer.
We use extrinsic unsigned transactions with signed extensions to enable the verification of the messages with the mobile public keys managed by the mobile registry pallet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mobile-tee-registry"><a class="header" href="#mobile-tee-registry">Mobile TEE Registry</a></h1>
<p>This is the module in charge of the mobile device public key registration and management in the blockchain substrate framework.</p>
<p><img src="./fig/Mobile_registration.svg" alt="mobile registration" /></p>
<p>When a <a href=".TTVP_client.html">TTVP Client</a>/Wallet is created, a Public/Private key pair is generated in the mobile Hardware Enclave/TEE. The public key is send to this registry and the private key remains on the devices, not accessible by anyone, even when it is rooted. The signature of all messages to the blockchain is triggered with the user's biometrics (also managed with TEE).</p>
<p>This <a href=".HBMK.html">hardware-backed mobile private key</a> on the device is used to generate an unsigned transaction extrinsic with signed option and this signature is verified by the blockchain with mobiles public keys registered in this module. (cf <a href="./TTVP.html">Trusted Transaction Validation Protocol</a>)</p>
<p>This pallet also register and manage all information related to the mobile TEE, security and identification of mobile devices when available. It includes the following  <a href="./HBMK.html">key and ID Attestation</a> and other hardware protected  features like  <a href=".https://source.android.com/security/protected-confirmation">protected confirmation</a>, mobile app signing, etc...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mobile-wallet-demo-app"><a class="header" href="#mobile-wallet-demo-app">Mobile Wallet Demo App</a></h1>
<p>The mobile wallet demo app include mainly a <a href="./TTVP_client.html">Trusted Transaction Validation Protocol client</a> that is securely linked with the blockchain through <a href="./Mobile_Registry.html">mobile registry</a></p>
<p>It also includes a wallet UI to perform transactions,
following are wallet screenshots of the main screens.</p>
<h2 id="portfolio-screens"><a class="header" href="#portfolio-screens">Portfolio Screens</a></h2>
<img src="./fig/Wallet_Menu_Black_Border.png" alt="wallet menu" width="300"/>
..
<img src="./fig/Wallet_Menu_White_Border.png" alt="wallet menu"  width="300"/>
<h2 id="profile-screens"><a class="header" href="#profile-screens">Profile Screens</a></h2>
<img src="./fig/Wallet_Profile_Black_Border.png" alt="wallet menu" width="300"/>
..
<img src="./fig/Wallet_Profile_White_Border.png" alt="wallet menu"  width="300"/>
<h2 id="send-screens"><a class="header" href="#send-screens">Send Screens</a></h2>
<h3 id="tap-currency"><a class="header" href="#tap-currency">Tap Currency</a></h3>
<img src="./fig/Wallet_Send_Tap_Black_Border.png" alt="wallet menu" width="300"/>
..
<img src="./fig/Wallet_Send_Tap_White_Border.png" alt="wallet menu"  width="300"/>
<h3 id="tap-contact"><a class="header" href="#tap-contact">Tap Contact</a></h3>
<img src="./fig/Wallet_Send_Tap_Contact_Black_Border.png" alt="wallet menu" width="300"/>
..
<img src="./fig/Wallet_Send_Tap_Contact_White_Border.png" alt="wallet menu"  width="300"/>
<h3 id="send"><a class="header" href="#send">Send</a></h3>
<img src="./fig/Wallet_Send_Black_Border.png" alt="wallet menu" width="300"/>
..
<img src="./fig/Wallet_Send_White_Border.png" alt="wallet menu"  width="300"/>
<h2 id="send-a-currency"><a class="header" href="#send-a-currency">Send a Currency</a></h2>
<img src="./fig/Send_Currency_Demo.gif" alt="wallet menu"  width="300"/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-transaction-validation-protocol-client"><a class="header" href="#trusted-transaction-validation-protocol-client">Trusted Transaction Validation Protocol client</a></h1>
<p>This is the client software embedded in an app or browser in the future that  enables the secure confirmation of any transactions or sensitive operation with an hardware level security.
(cf <a href="./TTVP.html">Tusted Transaction Validation Protocol</a>)</p>
<p>It implements the <a href="./TAUI.html">Trusted Authentication and User Interface Layer</a> combined with <a href="./HBMK.html">Harware-backed Mobile Key</a> and is regsitered in the <a href="./Mobile_Registry.html">Mobile TEE Registry</a></p>
<h2 id="architecture-and-security"><a class="header" href="#architecture-and-security">Architecture and Security</a></h2>
<p><img src="./fig/App_architecture.svg" alt="App architecture" /></p>
<blockquote>
<p>Green boxes are secure as well as garbled circuit evaluation in Dark Grey
it prevents state of the art Banking trojan attacks on the mobile</p>
</blockquote>
<p>This client is based on a substrate client on the mobile to communicate through unsigned extrinsic with signed option and substrate events with the blockchain. It enables the mobile to be registered with the mobile TEE registry pallet. </p>
<p>It also include an IPFS client to retrieve the cid of the <a href="./VC-GC.html">Visual Cryptography Display</a> i.e the one-time <a href=",/GC.html">Garbled Circuit</a> program generated for each transaction  by the <a href="./GCF.html">Garbled Circuit Factory</a> managed by the blockchain.</p>
<p>The previous circuit is used to compose the <a href="./TAUI.html">Trusted Authentication and User Interface Layer</a> i.e <code>Secure UI Screen</code> that evaluates and renders the circuit to enable the user to confirm a transaction/sensitive operation with a <code>one-time code</code></p>
<p>This Secure UI layer relies on a garbled circuit evaluator and a renderer to display the result of its evaluation directly to the framebuffer.</p>
<h2 id="ttvp-client-components"><a class="header" href="#ttvp-client-components">TTVP client components</a></h2>
<p>Following are the main components of the mobile client</p>
<h3 id="substrate-client"><a class="header" href="#substrate-client">Substrate Client</a></h3>
<p><a href="https://github.com/Interstellar-Network/wallet-app/blob/master/shared/rust/substrate-client/src/lib.rs">wallet-app/shared/rust/substrate-client/src</a></p>
<p>following are the main extrinsics used</p>
<h4 id="extrinsic_garble_and_strip_display_circuits_package_signed"><a class="header" href="#extrinsic_garble_and_strip_display_circuits_package_signed"><code>extrinsic_garble_and_strip_display_circuits_package_signed</code></a></h4>
<p>Get garbled Circuit package from ocwGarble pallet</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extrinsic_garble_and_strip_display_circuits_package_signed(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    tx_message: &amp;str,
) -&gt; Hash {
    ////////////////////////////////////////////////////////////////////////////
    // // &quot;set the recipient&quot;
    // let to = AccountKeyring::Bob.to_account_id();

    // // &quot;the names are given as strings&quot;
    // #[allow(clippy::redundant_clone)]
    // let xt: UncheckedExtrinsicV4&lt;_&gt; = compose_extrinsic!(
    //     api.clone(),
    //     &quot;Balances&quot;,
    //     &quot;transfer&quot;,
    //     GenericAddress::Id(to),
    //     Compact(42_u128)
    // );
    ////////////////////////////////////////////////////////////////////////////
    #[allow(clippy::redundant_clone)]
    let xt: UncheckedExtrinsicV4&lt;_&gt; = compose_extrinsic!(
        api.clone(),
        // MUST match the name in /substrate-offchain-worker-demo/runtime/src/lib.rs
        &quot;OcwGarble&quot;,
        // MUST match the call in /substrate-offchain-worker-demo/pallets/ocw-circuits/src/lib.rs
        &quot;garble_and_strip_display_circuits_package_signed&quot;,
        tx_message.as_bytes().to_vec()
    );

    println!(&quot;[+] Composed Extrinsic:\n {:?}\n&quot;, xt);

    // &quot;send and watch extrinsic until InBlock&quot;
    let tx_hash = api
        .send_extrinsic(xt.hex_encode(), XtStatus::InBlock)
        .unwrap();
    println!(&quot;[+] Transaction got included. Hash: {:?}&quot;, tx_hash);

    tx_hash.expect(&quot;send_extrinsic failed&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="extrinsic_register_mobile"><a class="header" href="#extrinsic_register_mobile"><code>extrinsic_register_mobile</code></a></h4>
<p>send the mobile public key to be registered in the Mobile Registry pallet</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extrinsic_register_mobile(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    pub_key: Vec&lt;u8&gt;,
) -&gt; Hash {
    #[allow(clippy::redundant_clone)]
    let xt: UncheckedExtrinsicV4&lt;_&gt; = compose_extrinsic!(
        api.clone(),
        // MUST match the name in /substrate-offchain-worker-demo/runtime/src/lib.rs
        &quot;MobileRegistry&quot;,
        // MUST match the call in /substrate-offchain-worker-demo/pallets/ocw-circuits/src/lib.rs
        &quot;register_mobile&quot;,
        pub_key
    );

    println!(&quot;[+] Composed Extrinsic:\n {:?}\n&quot;, xt);

    // &quot;send and watch extrinsic until InBlock&quot;
    let tx_hash = api
        .send_extrinsic(xt.hex_encode(), XtStatus::InBlock)
        .unwrap();
    println!(&quot;[+] Transaction got included. Hash: {:?}&quot;, tx_hash);

    tx_hash.expect(&quot;send_extrinsic failed&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="extrinsic_check_input"><a class="header" href="#extrinsic_check_input"><code>extrinsic_check_input</code></a></h3>
<p>check user input i.e one-time-code inputted on the randomized keypad</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extrinsic_check_input(
    api: &amp;Api&lt;sp_core::sr25519::Pair, WsRpcClient&gt;,
    ipfs_cid: Vec&lt;u8&gt;,
    input_digits: Vec&lt;u8&gt;,
) -&gt; Hash {
    #[allow(clippy::redundant_clone)]
    let xt: UncheckedExtrinsicV4&lt;_&gt; = compose_extrinsic!(
        api.clone(),
        // MUST match the name in /substrate-offchain-worker-demo/runtime/src/lib.rs
        &quot;TxValidation&quot;,
        // MUST match the call in /substrate-offchain-worker-demo/pallets/ocw-circuits/src/lib.rs
        &quot;check_input&quot;,
        ipfs_cid,
        input_digits
    );

    println!(&quot;[+] Composed Extrinsic:\n {:?}\n&quot;, xt);

    // &quot;send and watch extrinsic until InBlock&quot;
    let tx_hash = api
        .send_extrinsic(xt.hex_encode(), XtStatus::InBlock)
        .unwrap();
    println!(&quot;[+] Transaction got included. Hash: {:?}&quot;, tx_hash);

    tx_hash.expect(&quot;send_extrinsic failed&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="garble-circuit-evaluator"><a class="header" href="#garble-circuit-evaluator">Garble Circuit Evaluator</a></h3>
<p>This is the high level part in rust that encapsulated call to lower level C++ evaluator</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use cxx;

use aes::cipher::{
    generic_array::{typenum::consts::U16, GenericArray},
    BlockEncrypt, KeyInit,
};
use aes::Aes128;

#[cxx::bridge]
pub mod ffi {

    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MyRustAes;

        unsafe fn encrypt_block(aes: &amp;MyRustAes, low: &amp;mut u64, high: &amp;mut u64);

        /// param: key: usually a PGC's global_key field
        // Box&lt;&gt; else &quot;returning opaque Rust type by value is not supported&quot;
        unsafe fn init_aes(key_low: u64, key_high: u64) -&gt; Box&lt;MyRustAes&gt;;
    }

    unsafe extern &quot;C++&quot; {
        include!(&quot;circuit-evaluate/src/rust_wrapper.h&quot;);

        type EvaluateWrapper;

        /// Create a new EvaluateWrapper, to be used later eg
        /// let evaluate_wrapper = ffi::new_evaluate_wrapper(...);
        /// evaluate_wrapper.EvaluateWithInputs(...); etc
        ///
        /// param: pgarbled_buffer can be a FULL, or a STRIPPED circuit
        /// typically in PROD we use STRIPPED ones, but for tests/dev we keep compat with FULL circuits
        /// [in which case] packmsg_buffer can be empty
        fn new_evaluate_wrapper(
            pgarbled_buffer: Vec&lt;u8&gt;,
            packmsg_buffer: Vec&lt;u8&gt;,
        ) -&gt; UniquePtr&lt;EvaluateWrapper&gt;;

        /// PROD version
        /// inputs are randomized, outputs are externally given
        /// typically outputs points to some kind of &quot;Texture data&quot;
        fn EvaluateWithPackmsg(self: Pin&lt;&amp;mut EvaluateWrapper&gt;, outputs: &amp;mut Vec&lt;u8&gt;);
        /// TEST/DEV only
        /// PROD uses randomize inputs
        fn EvaluateWithPackmsgWithInputs(&amp;self, inputs: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;
        /// TEST/DEV only
        /// PROD is using the PACKMSG version
        fn EvaluateWithInputs(&amp;self, inputs: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;

        fn GetNbInputs(&amp;self) -&gt; usize;
        fn GetNbOutputs(&amp;self) -&gt; usize;
        fn GetWidth(&amp;self) -&gt; usize;
        fn GetHeight(&amp;self) -&gt; usize;
    }
}

/// We MUST impl Send+Sync b/c EvaluateWrapper is used as a Bevy's Resource
/// EvaluateWithPackmsg/etc use a &quot;const&quot; PGC so on that part we are thread safe
/// BUT EvaluateWithPackmsg in circuit_evaluate/src/rust_wrapper.cpp MAY NOT be thread safe
/// depending on where &quot;outputs&quot; are(eg NOT thread safe if a class field, thread safe if returning std::vector)
unsafe impl Send for ffi::EvaluateWrapper {}
unsafe impl Sync for ffi::EvaluateWrapper {}

pub struct MyRustAes {
    pub aes: Aes128,
}

pub fn encrypt_block(aes: &amp;MyRustAes, low: &amp;mut u64, high: &amp;mut u64) {
    // init &quot;block&quot; from &quot;high+low&quot;
    // TODO or better instead of &quot;high, low&quot; params: rewrite to accept a param like &quot;key: *const c_char&quot; and use reinterpret_cast(&amp;this) in block.h?
    let input_vec: Vec&lt;u8&gt; = if cfg!(target_endian = &quot;big&quot;) {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(low.to_be_bytes());
        v.extend(high.to_be_bytes());
        v
    } else {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(low.to_le_bytes());
        v.extend(high.to_le_bytes());
        v
    };

    let mut block: GenericArray&lt;u8, U16&gt; = GenericArray::clone_from_slice(input_vec.as_slice());

    aes.aes.encrypt_block(&amp;mut block);

    let low_arr: [u8; 8] = block.as_slice()[..8].try_into().expect(&quot;Wrong length&quot;);
    let high_arr: [u8; 8] = block.as_slice()[8..].try_into().expect(&quot;Wrong length&quot;);

    if cfg!(target_endian = &quot;big&quot;) {
        *low = u64::from_be_bytes(low_arr);
        *high = u64::from_be_bytes(high_arr);
    } else {
        *low = u64::from_le_bytes(low_arr);
        *high = u64::from_le_bytes(high_arr);
    }
}

fn init_aes(key_low: u64, key_high: u64) -&gt; Box&lt;MyRustAes&gt; {
    let key: Vec&lt;u8&gt; = if cfg!(target_endian = &quot;big&quot;) {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(key_low.to_be_bytes());
        v.extend(key_high.to_be_bytes());
        v
    } else {
        let mut v: Vec&lt;u8&gt; = vec![];
        v.extend(key_low.to_le_bytes());
        v.extend(key_high.to_le_bytes());
        v
    };

    Box::new(MyRustAes {
        aes: Aes128::new_from_slice(&amp;key).unwrap(),
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>low level C++ garbled circuits evaluator part</p>
<p><a href="https://github.com/Interstellar-Network/wallet-app/tree/master/shared/rust/circuit_evaluate/src/cpp">wallet-app/shared/rust/circuit_evaluate/src/cpp/</a></p>
<h3 id="renderer"><a class="header" href="#renderer">Renderer</a></h3>
<p>This is the layer in charge of writting the results of display circuits evaluation directly to the framebuffer through GPU shaders
<a href="https://github.com/Interstellar-Network/wallet-app/tree/master/shared/rust/renderer">wallet-app/shared/rust/renderer</a></p>
<p>One of the most critical part of the renderer, responsible to create surface view in which renderer will display the texture resulting of circuits evaluation/execution</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use android_logger::Config;
use bevy::prelude::Color;
use common::DisplayStrippedCircuitsPackageBuffers;
use core::ffi::c_void;
use jni::objects::{JClass, JObject, JString, ReleaseMode};
use jni::sys::{jbyteArray, jfloat, jfloatArray, jint, jlong, jstring};
use jni::JNIEnv;
use jni_fn::jni_fn;
use log::{debug, info, Level};
use raw_window_handle::{AndroidNdkHandle, RawWindowHandle};

// #[cfg(target_os = &quot;android&quot;)]
use android_logger::FilterBuilder;

use crate::{
    init_app, my_raw_window_handle, update_texture_utils, vertices_utils::Rect, App,
    TextureUpdateCallbackType,
};

extern &quot;C&quot; {
    pub fn ANativeWindow_fromSurface(env: JNIEnv, surface: JObject) -&gt; usize;
    // TODO maybe use:ANativeWindow_getFormat?
    pub fn ANativeWindow_getHeight(window_ptr: usize) -&gt; u32;
    pub fn ANativeWindow_getWidth(window_ptr: usize) -&gt; u32;
}

pub fn get_raw_window_handle(env: JNIEnv, surface: JObject) -&gt; (RawWindowHandle, u32, u32) {
    let a_native_window = unsafe { ANativeWindow_fromSurface(env, surface) };
    let mut handle = AndroidNdkHandle::empty();
    handle.a_native_window = a_native_window as *mut c_void;

    let width = unsafe { ANativeWindow_getWidth(a_native_window) };
    let height = unsafe { ANativeWindow_getHeight(a_native_window) };

    return (RawWindowHandle::AndroidNdk(handle), width, height);
}

// TODO static state? or return Box&lt;State&gt; in initSurface and store as &quot;long&quot; in Kotlin?
// static mut state: Option&lt;State&gt; = None;size

fn init_surface(
    env: JNIEnv,
    surface: JObject,
    messageRects: jfloatArray,
    pinpadRects: jfloatArray,
    pinpad_nb_cols: usize,
    pinpad_nb_rows: usize,
    message_text_color: Color,
    circle_text_color: Color,
    circle_color: Color,
    background_color: Color,
    message_pgarbled_buf: Vec&lt;u8&gt;,
    message_packmsg_buf: Vec&lt;u8&gt;,
    pinpad_pgarbled_buf: Vec&lt;u8&gt;,
    pinpad_packmsg_buf: Vec&lt;u8&gt;,
) -&gt; jlong {
    // TODO use loggers.rs(same as substrate-client)
    // WARNING: conflicts with substrate-client/src/loggers.rs
    // only the first one called is taken into account
    android_logger::init_once(
        Config::default()
            .with_min_level(Level::Info)
            .with_tag(&quot;interstellar&quot;)
            .with_filter(
                FilterBuilder::new()
                    // useful: wgpu_hal=info
                    .parse(&quot;info,jni::crate=debug&quot;)
                    .build(),
            ),
    );

    let (handle, width, height) = get_raw_window_handle(env, surface);
    log::debug!(
        &quot;initSurface: got handle! width = {}, height = {}&quot;,
        width,
        height
    );
    info!(&quot;initSurface before new_native&quot;);

    let mut message_rects_vec = unsafe {
        convert_rect_floatArr_to_vec_rect(env, messageRects, width as f32, height as f32)
    };
    let mut pinpad_rects_vec =
        unsafe { convert_rect_floatArr_to_vec_rect(env, pinpadRects, width as f32, height as f32) };
    assert!(
        message_rects_vec.len() == 1,
        &quot;should have only ONE message_rects!&quot;,
    );
    assert!(
        pinpad_rects_vec.len() == pinpad_nb_cols * pinpad_nb_rows,
        &quot;pinpadRects length MUST = pinpad_nb_cols * pinpad_nb_rows!&quot;
    );
    // get the only Rect from &quot;message_rects&quot;; owned
    let message_rect = message_rects_vec.swap_remove(0);
    debug!(&quot;init_surface: message_rect: {:?}&quot;, message_rect);
    // pinpad: convert the Vec&lt;&gt; into a 2D matrix
    let mut pinpad_rects = ndarray::Array2::&lt;Rect&gt;::default((pinpad_nb_rows, pinpad_nb_cols));
    for row in 0..pinpad_nb_rows {
        for col in 0..pinpad_nb_cols {
            let index = col + row * pinpad_nb_cols;
            debug!(
                &quot;init_surface: col: {:?}, row: {:?}, index: {}&quot;,
                col, row, index
            );
            pinpad_rects[[row, col]] = pinpad_rects_vec.get(index).unwrap().clone();
            // swap_remove takes the first(0 in this case), so no need to compute &quot;let index = col + row * pinpad_nb_cols;&quot;
            // pinpad_rects[[row, col]] = pinpad_rects_vec.swap_remove(0);
            // FAIL: the order ends up messed up, which means the &quot;cancel&quot; and &quot;go&quot; button are not in the right place
        }
    }

    // TODO?
    // let size = winit::dpi::PhysicalSize::new(width, height);
    // &amp;awindow,
    //     size,
    //     update_texture_data,
    //     vertices,
    //     indices,
    //     texture_base,
    let mut app = App::new();

    log::debug!(&quot;before init_app&quot;);
    init_app(
        &amp;mut app,
        message_rect,
        pinpad_rects,
        pinpad_nb_cols,
        pinpad_nb_rows,
        message_text_color,
        circle_text_color,
        circle_color,
        background_color,
        // DEV/DEBUG: offline
        // include_bytes!(&quot;../examples/data/message_224x96.pgarbled.stripped.pb.bin&quot;).to_vec(),
        // include_bytes!(&quot;../examples/data/message_224x96.packmsg.pb.bin&quot;).to_vec(),
        // include_bytes!(&quot;../examples/data/pinpad_590x50.pgarbled.stripped.pb.bin&quot;).to_vec(),
        // include_bytes!(&quot;../examples/data/pinpad_590x50.packmsg.pb.bin&quot;).to_vec(),
        message_pgarbled_buf,
        message_packmsg_buf,
        pinpad_pgarbled_buf,
        pinpad_packmsg_buf,
    );

    // NOTE: MUST be after init_app(or rather DefaultPlugins) else
    // panic at: &quot;let mut windows = world.get_resource_mut::&lt;Windows&gt;().unwrap();&quot;
    #[cfg(target_os = &quot;android&quot;)]
    crate::init_window(
        &amp;mut app,
        width,
        height,
        my_raw_window_handle::MyRawWindowHandleWrapper::new(handle),
    );

    info!(&quot;init_app ok!&quot;);

    Box::into_raw(Box::new(app)) as jlong
    // TODO static state?
    // 0
}

/// IMPORTANT: pinpadRects is assumed to be given from top-&gt;bottom, left-&gt;right
/// ie pinpadRects[0] is top left, pinpadRects[12] is bottom right
///
/// param: surface: SHOULD come from &quot;override fun surfaceCreated(holder: SurfaceHolder)&quot; holder.surface
/// param: circuits_package_ptr: MUST be the returned value from substrate-client/src/jni_wrapper.rs GetCircuits
///     NOTE: the pointer is NOT valid after this function returns!
#[no_mangle]
#[jni_fn(&quot;gg.interstellar.wallet.RustWrapper&quot;)]
pub unsafe fn initSurface(
    env: JNIEnv,
    _: JClass,
    surface: JObject,
    messageRects: jfloatArray,
    pinpadRects: jfloatArray,
    pinpad_nb_cols: jint,
    pinpad_nb_rows: jint,
    message_text_color_hex: JString,
    circle_text_color_hex: JString,
    circle_color_hex: JString,
    background_color_hex: JString,
    circuits_package_ptr: jlong,
) -&gt; jlong {
    // USE A Box, that way the pointer is properly cleaned up when exiting this function
    // let circuits_package = &amp;mut *(circuits_package_ptr as *mut DisplayStrippedCircuitsPackageBuffers);
    let display_stripped_circuits_package_buffers: Box&lt;DisplayStrippedCircuitsPackageBuffers&gt; =
        Box::from_raw(circuits_package_ptr as *mut _);

    init_surface(
        env,
        surface,
        messageRects,
        pinpadRects,
        pinpad_nb_cols.try_into().unwrap(),
        pinpad_nb_rows.try_into().unwrap(),
        Color::hex::&lt;String&gt;(
            env.get_string(message_text_color_hex)
                .expect(&quot;Couldn't get java string message_text_color_hex!&quot;)
                .into(),
        )
        .unwrap(),
        Color::hex::&lt;String&gt;(
            env.get_string(circle_text_color_hex)
                .expect(&quot;Couldn't get java string circle_text_color_hex!&quot;)
                .into(),
        )
        .unwrap(),
        Color::hex::&lt;String&gt;(
            env.get_string(circle_color_hex)
                .expect(&quot;Couldn't get java string circle_color_hex!&quot;)
                .into(),
        )
        .unwrap(),
        Color::hex::&lt;String&gt;(
            env.get_string(background_color_hex)
                .expect(&quot;Couldn't get java string background_color_hex!&quot;)
                .into(),
        )
        .unwrap(),
        display_stripped_circuits_package_buffers
            .message_pgarbled_buf
            .clone(),
        display_stripped_circuits_package_buffers
            .message_packmsg_buf
            .clone(),
        display_stripped_circuits_package_buffers
            .pinpad_pgarbled_buf
            .clone(),
        display_stripped_circuits_package_buffers
            .pinpad_packmsg_buf
            .clone(),
    )
}

#[no_mangle]
#[jni_fn(&quot;gg.interstellar.wallet.RustWrapper&quot;)]
pub unsafe fn render(_env: *mut JNIEnv, _: JClass, obj: jlong) {
    // TODO static state?
    let app = &amp;mut *(obj as *mut App);
    // DO NOT use app.run() cf https://github.com/bevyengine/bevy/blob/main/examples/app/custom_loop.rs
    // calling app.run() makes Android display not updating after a few loops.
    // The texture are setup, circuit_evaluate runs a few times and then nothing changes anymore
    // change_texture_message/change_texture_pinpad are NOT called anymore
    // app.run();
    app.update();
}

#[no_mangle]
#[jni_fn(&quot;gg.interstellar.wallet.RustWrapper&quot;)]
pub unsafe fn cleanup(_env: *mut JNIEnv, _: JClass, obj: jlong) {
    let _obj: Box&lt;App&gt; = Box::from_raw(obj as *mut _);
}

/// Convert a floatArray like [left0, top0, right0, bottom0, left1, top2, right1, bottom1, ...]
/// into vec[Rect(left0, top0, right0, bottom0),Rect(left1, top2, right1, bottom1),...]
///
/// NOTE: will also convert the Coords to match Bevy
/// eg a Rect on the top of screen, full width:
//  0 = {Rect@20731} Rect.fromLTRB(0.0, 0.0, 1080.0, 381.0)
//  message_rects_flattened = {ArrayList@20533}  size = 4
//   0 = {Float@20689} 0.0
//   1 = {Float@20690} 0.0
//   2 = {Float@20691} 1080.0
//   3 = {Float@20692} 381.0
// will be converted to:
// Rect(left:0.0, top: height - 0.0, right: 1080, bottom: height - 381.0)
unsafe fn convert_rect_floatArr_to_vec_rect(
    env: JNIEnv,
    rectsFloatArray: jfloatArray,
    width: f32,
    height: f32,
) -&gt; Vec&lt;Rect&gt; {
    let rects_floatarr = env
        .get_float_array_elements(rectsFloatArray, ReleaseMode::NoCopyBack)
        .unwrap();
    assert_ne!(
        rects_floatarr.size().unwrap(),
        0,
        &quot;rects_floatarr is empty!&quot;
    );
    assert_eq!(
        rects_floatarr.size().unwrap() % 4,
        0,
        &quot;rects_floatarr MUST be % 4!&quot;
    );

    let mut rects_vec =
        Vec::&lt;Rect&gt;::with_capacity((rects_floatarr.size().unwrap() / 4).try_into().unwrap());
    let mut idx = 0;
    for i in (0..rects_floatarr.size().unwrap()).step_by(4) {
        rects_vec.insert(
            idx,
            Rect::new_to_ndc_android(
                // message_rects_jlist.get(i).unwrap().unwrap().into(),
                // message_rects_jlist.get(i + 1).unwrap().unwrap().into(),
                // message_rects_jlist.get(i + 2).unwrap().unwrap().into(),
                // message_rects_jlist.get(i + 3).unwrap().unwrap().into(),
                *rects_floatarr.as_ptr().offset(i.try_into().unwrap()),
                *rects_floatarr.as_ptr().offset((i + 1).try_into().unwrap()),
                *rects_floatarr.as_ptr().offset((i + 2).try_into().unwrap()),
                *rects_floatarr.as_ptr().offset((i + 3).try_into().unwrap()),
                width,
                height,
            ),
        );
        idx += 1;
    }

    rects_vec
}

// https://github.com/jni-rs/jni-rs/blob/master/tests/util/mod.rs
#[cfg(test)]
#[cfg(target_os = &quot;linux&quot;)] // we do not need jni features = [&quot;invocation&quot;] for Android
fn jvm() -&gt; &amp;'static std::sync::Arc&lt;jni::JavaVM&gt; {
    static mut JVM: Option&lt;std::sync::Arc&lt;jni::JavaVM&gt;&gt; = None;
    static INIT: std::sync::Once = std::sync::Once::new();

    INIT.call_once(|| {
        let jvm_args = jni::InitArgsBuilder::new()
            .version(jni::JNIVersion::V8)
            .option(&quot;-Xcheck:jni&quot;)
            .build()
            .unwrap_or_else(|e| panic!(&quot;{:#?}&quot;, e));

        let jvm = jni::JavaVM::new(jvm_args).unwrap_or_else(|e| panic!(&quot;{:#?}&quot;, e));

        unsafe {
            JVM = Some(std::sync::Arc::new(jvm));
        }
    });

    unsafe { JVM.as_ref().unwrap() }
}

#[cfg(test)]
#[cfg(target_os = &quot;linux&quot;)] // we do not need jni features = [&quot;invocation&quot;] for Android
#[allow(dead_code)]
pub fn attach_current_thread() -&gt; jni::AttachGuard&lt;'static&gt; {
    jvm()
        .attach_current_thread()
        .expect(&quot;failed to attach jvm thread&quot;)
}

// cf https://github.com/jni-rs/jni-rs/blob/master/tests/jni_api.rs
#[cfg(target_os = &quot;linux&quot;)] // we do not need jni features = [&quot;invocation&quot;] for Android
#[test]
pub fn test_convert_rect_floatArr_to_vec_rect() {
    let env = attach_current_thread();

    //     result = {Rect[1]@20529}
    //  0 = {Rect@20731} Rect.fromLTRB(0.0, 0.0, 1080.0, 381.0)
    // message_rects_flattened = {ArrayList@20533}  size = 4
    //  0 = {Float@20689} 0.0
    //  1 = {Float@20690} 0.0
    //  2 = {Float@20691} 1080.0
    //  3 = {Float@20692} 381.0
    let buf: &amp;[jfloat] = &amp;[
        0.0 as jfloat,
        0.0 as jfloat,
        1080.0 as jfloat,
        381.0 as jfloat,
    ];
    let java_array = env
        .new_float_array(4)
        .expect(&quot;JNIEnv#new_float_array must create a Java jfloat array with given size&quot;);

    // Insert array elements
    let _ = env.set_float_array_region(java_array, 0, buf);

    let res = unsafe { convert_rect_floatArr_to_vec_rect(*env, java_array, 1080., 1920.) };

    assert_eq!(res[0], Rect::new(-0.5625, 1.0, 0.5625, 0.603125))
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="validation-screen"><a class="header" href="#validation-screen">Validation Screen</a></h3>
<p>High level screen in kotlin/jetpack compose or swift UI to display the surface view arrays generated directly by the GPU
This is just to illustrate that all the work is done by the lower level layers</p>
<p><a href="https://github.com/Interstellar-Network/wallet-app/blob/master/androidApp/src/main/java/gg/interstellar/wallet/android/ui/TxPinpadScreen.kt">TxPinpadScreen.kt</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-backed-mobile-key"><a class="header" href="#hardware-backed-mobile-key">Hardware-backed Mobile Key</a></h1>
<h2 id="hardware-keystore"><a class="header" href="#hardware-keystore">Hardware Keystore</a></h2>
<p><a href="https://source.android.com/security/keystore">Hardware-backed Keystore</a></p>
<p><img src="./fig/access-to-keymaster.png" alt="access keymaster" /></p>
<h2 id="attestation-management"><a class="header" href="#attestation-management">Attestation management</a></h2>
<p><a href="https://source.android.com/security/keystore/attestation">Key and ID Attestation | Android Open Source Project</a>
Verifying hardware-backed key pairs with Key Attestation</p>
<p><a href="https://stackoverflow.com/questions/61225795/how-to-check-whether-android-phone-supports-tee/64422042#64422042">How to check whether Android phone supports TEE</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Following are the prerequistes for testing</p>
<p><a href="./runtime_prerequisite.m">Runtime prerequisite</a> when a docker is provided to perform a demo for a given milestones</p>
<p><a href="./compilation_preequisite">Compilation prerequiste</a> when you need to build the executables from sources with dpendencies on lib_circuit &amp; lib_garbled libraries 
ex: to run Cargo test for GCF APIs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisite-installation-for-runtime"><a class="header" href="#prerequisite-installation-for-runtime">Prerequisite Installation for runtime</a></h1>
<h2 id="install-ipfs"><a class="header" href="#install-ipfs">Install IPFS</a></h2>
<ul>
<li><a href="https://github.com/ipfs/ipfs-desktop#install">IPFS Desktop Install</a>
- that way the full IPFS env is set up; alternatively you can just install go-ipfs</li>
<li><a href="https://docs.ipfs.io/install/command-line/#official-distributions">IPFS with go-ipfs client Install</a></li>
</ul>
<p>Installing ipfs on linux (without desktop):</p>
<pre><code class="language-sh">wget https://dist.ipfs.io/go-ipfs/v0.11.0/go-ipfs_v0.11.0_linux-amd64.tar.gz
</code></pre>
<pre><code class="language-sh">tar -xvzf go-ipfs_v0.11.0_linux-amd64.tar.gz
</code></pre>
<pre><code class="language- sh">cd go-ipfs
sudo bash install.sh
</code></pre>
<p>check ipfs</p>
<pre><code class="language-sh">ipfs --version
</code></pre>
<p>Set env var path and launch the ipfs deamon</p>
<pre><code class="language-sh">GO_IPFS_PATH=/usr/local/bin/ipfs

IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH init -p test
IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH config Addresses.API /ip4/0.0.0.0/tcp/5001
IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH daemon --enable-pubsub-experiment
</code></pre>
<blockquote>
<p>&quot;if you intend to use Docker you SHOULD be sure it is reachable by the containers
eg /ip4/0.0.0.0/tcp/5001&quot;</p>
</blockquote>
<p>deamon launch:</p>
<blockquote>
<p>wait for &quot;Initializing daemon...&quot; and &quot;ID&quot;: &quot;12D3KooWKDUcaDuzxqQeSvpwtE8kQKAGNFA1BdmNECk47iYMRA6F&quot;,&quot;</p>
</blockquote>
<pre><code class="language-sh">Initializing daemon...
go-ipfs version: 0.12.0
Repo version: 12
System version: amd64/linux
Golang version: go1.16.12
Swarm listening on /ip4/127.0.0.1/tcp/40319
Swarm listening on /p2p-circuit
Swarm announcing /ip4/127.0.0.1/tcp/40319
API server listening on /ip4/127.0.0.1/tcp/45167
WebUI: http://127.0.0.1:45167/webui
Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/34533
Daemon is ready
</code></pre>
<pre><code class="language-json">{
    &quot;ID&quot;: &quot;12D3KooWKDUcaDuzxqQeSvpwtE8kQKAGNFA1BdmNECk47iYMRA6F&quot;,
    &quot;PublicKey&quot;: &quot;CAESIIuk1CX4SOWG29N7DxhOuFYpzX0KUgsLi6EWVNnoylMU&quot;,
    &quot;Addresses&quot;: [
    &quot;/ip4/127.0.0.1/tcp/40319/p2p/12D3KooWKDUcaDuzxqQeSvpwtE8kQKAGNFA1BdmNECk47iYMRA6F&quot;
    ],
    &quot;AgentVersion&quot;: &quot;go-ipfs/0.12.0/&quot;,
    &quot;ProtocolVersion&quot;: &quot;ipfs/0.1.0&quot;,
    &quot;Protocols&quot;: [
            &quot;/floodsub/1.0.0&quot;,
            &quot;/ipfs/bitswap&quot;,
            &quot;/ipfs/bitswap/1.0.0&quot;,
            &quot;/ipfs/bitswap/1.1.0&quot;,
            &quot;/ipfs/bitswap/1.2.0&quot;,
            &quot;/ipfs/id/1.0.0&quot;,
            &quot;/ipfs/id/push/1.0.0&quot;,
            &quot;/ipfs/lan/kad/1.0.0&quot;,
            &quot;/ipfs/ping/1.0.0&quot;,
            &quot;/libp2p/autonat/1.0.0&quot;,
            &quot;/libp2p/circuit/relay/0.1.0&quot;,
            &quot;/libp2p/circuit/relay/0.2.0/stop&quot; ,
            &quot;/meshsub/1.0.0&quot;,
            &quot;/meshsub/1.1.0&quot;,
            &quot;/p2p/id/delta/1.0.0&quot;,
            &quot;/x/&quot;
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisite-installation-for-compilation"><a class="header" href="#prerequisite-installation-for-compilation">Prerequisite installation for compilation</a></h1>
<h2 id="install-ipfs-1"><a class="header" href="#install-ipfs-1">Install IPFS</a></h2>
<p><a href="https://docs.ipfs.io/install/">IPFS Installation</a></p>
<h2 id="update-cmake--if--322"><a class="header" href="#update-cmake--if--322">Update cmake  if &lt; 3.22</a></h2>
<p>Check your that your current cmake version is at least 3.22:</p>
<pre><code class="language-sh">cmake --version
</code></pre>
<p>if not:
<a href="https://cmake.org/install/">check install</a></p>
<p><a href="https://cmake.org/download/">download binaries</a></p>
<pre><code class="language-sh">wget https://github.com/Kitware/CMake/releases/download/v3.22.3/cmake-3.22.3-linux-x86_64.sh
chmod +x cmake-3.22.3-linux-x86_64.sh
sudo mkdir /opt/cmake-3.22/
sudo ./cmake-3.22.3-linux-x86_64.sh --skip-license --prefix=/opt/cmake-3.22/
</code></pre>
<p>check the version</p>
<pre><code class="language-sh">cmake --version
</code></pre>
<h2 id="install-ninja"><a class="header" href="#install-ninja">Install ninja</a></h2>
<pre><code class="language-sh">wget https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip
apt-get install unzip
sudo Zip ninja-linux.zip -d /usr/local/bin
sudo chmod +x /usr/local/bin/ninja
</code></pre>
<h2 id="add-the-following-list-of-softwarelibs"><a class="header" href="#add-the-following-list-of-softwarelibs">Add the following list of software/libs</a></h2>
<pre><code class="language-sh">apt-get install -y \
    bison \
    flex \
    libreadline-dev \
    libtcl \
    tcl8.6-dev \
    tcl-dev \
    tk8.6-dev \
    tk-dev \
    libboost-filesystem-dev \
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m1-delivery"><a class="header" href="#m1-delivery">M1 Delivery</a></h1>
<h2 id="garbled-circuit-factory-gcf-and-circuit-types-overview"><a class="header" href="#garbled-circuit-factory-gcf-and-circuit-types-overview">Garbled Circuit Factory (GCF) and Circuit types overview</a></h2>
<ul>
<li><a href="./GCF.html">GCF generic pipeline for Garbled Circuit (GC) production</a>
<ul>
<li><a href="./GC.html">Basic GC structure</a></li>
<li><a href="./VC-GC.html">Visual Cryptography display principles</a></li>
</ul>
</li>
</ul>
<h2 id="code-documentation"><a class="header" href="#code-documentation">Code documentation</a></h2>
<ul>
<li><a href="./GCF_pipeline_detailed.html">GCF detailed pipeline for the production of display circuits</a></li>
<li><a href="./GCF_API.html">GCF APIs for GCF OCWs</a></li>
</ul>
<h2 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h2>
<blockquote>
<p>Following is a testing guide and tutorial to launch tests related to M1 milestone Mostly integration test. It also includes the prerequiste i.e additional software and libraries that need to be installed in order to run the unit tests without the M1 docker.</p>
</blockquote>
<p><a href="https://book.interstellar.gg/GCF_API_Test_Guide.html">GCF APIs Testing Guide</a></p>
<p>CLIs to test <code>lib_circuit</code> and <code>lib_garble</code> C++ libraries linked with the GCF external service gRPC server:</p>
<ul>
<li><a href="https://github.com/Interstellar-Network/lib_circuits/tree/main/tests">lib_circuit test CLIs</a></li>
<li><a href="https://github.com/Interstellar-Network/lib_garble/tree/main/tests">lib_garble test CLIs</a></li>
</ul>
<blockquote>
<p>not explicity required for this milestone but potentially useful for fine tuning generic circuit designs</p>
</blockquote>
<h2 id="docker-demo-tutorial"><a class="header" href="#docker-demo-tutorial">Docker demo tutorial</a></h2>
<p><a href="./M1_demo_tutorial.html">Demo tutorial</a></p>
<h2 id="article"><a class="header" href="#article">Article</a></h2>
<p>Link to medium article (will be avalaible soon) on this book</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m1-docker-demo-tutorial"><a class="header" href="#m1-docker-demo-tutorial">M1 Docker Demo Tutorial</a></h1>
<h2 id="check-prerquiste"><a class="header" href="#check-prerquiste">Check prerquiste</a></h2>
<p><a href="./runtime_prerequisite.html">runtime prerequiste</a></p>
<h2 id="set-up-demo"><a class="header" href="#set-up-demo">Set-up Demo</a></h2>
<h3 id="launch-ipfs-deamon"><a class="header" href="#launch-ipfs-deamon">Launch ipfs deamon</a></h3>
<pre><code class="language-sh">GO_IPFS_PATH=/usr/local/bin/ipfs

IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH init -p test
IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH config Addresses.API /ip4/0.0.0.0/tcp/5001
</code></pre>
<pre><code>IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH daemon --enable-pubsub-experiment
</code></pre>
<pre><code class="language-sh">Initializing daemon...
go-ipfs version: 0.11.0
Repo version: 11
System version: amd64/linux
Golang version: go1.16.12
Swarm listening on /ip4/127.0.0.1/tcp/46507
Swarm listening on /p2p-circuit
Swarm announcing /ip4/127.0.0.1/tcp/46507
API server listening on /ip4/0.0.0.0/tcp/5001
WebUI: http://0.0.0.0:5001/webui
Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/38297
Daemon is ready
</code></pre>
<h3 id="launch-dockers"><a class="header" href="#launch-dockers">Launch dockers:</a></h3>
<h4 id="launch-api_circuit-docker"><a class="header" href="#launch-api_circuit-docker">Launch api_circuit docker</a></h4>
<pre><code class="language-sh">docker run -it --name api_circuits --rm -p 3000:3000 --env RUST_LOG=&quot;warn,info,debug&quot; ghcr.io/interstellar-network/api_circuits:milestone1 /usr/local/bin/api_circuits --ipfs-server-multiaddr /ip4/172.17.0.1/tcp/5001
</code></pre>
<h4 id="launch-api_garble-docker"><a class="header" href="#launch-api_garble-docker">Launch api_garble docker</a></h4>
<pre><code class="language-sh">docker run -it --name api_garble --rm -p 3001:3000 --env RUST_LOG=&quot;warn,info,debug&quot; ghcr.io/interstellar-network/api_garble:milestone1 /usr/local/bin/api_garble --ipfs-server-multiaddr /ip4/172.17.0.1/tcp/5001
</code></pre>
<h3 id="launch-substrate-demo-chain-with-ocw"><a class="header" href="#launch-substrate-demo-chain-with-ocw">Launch substrate demo chain with OCW</a></h3>
<pre><code>git clone --branch=interstellar --recursive git@github.com:Interstellar-Network/subs trate-offchain-worker-demo.git
</code></pre>
<p>then</p>
<pre><code>cd substrate-offchain-worker-demo 
</code></pre>
<p>build the substrate chain....</p>
<pre><code class="language-sh">RUST_LOG=&quot;warn,info&quot; cargo run -- --dev --tmp
</code></pre>
<blockquote>
<p>Important: the node log will display some results i.e cid that you will have to copy paste to perform the demo</p>
</blockquote>
<h3 id="launch-a-generic-substrate-fromt-end"><a class="header" href="#launch-a-generic-substrate-fromt-end">Launch a generic Substrate Fromt-end</a></h3>
<p>Use the following <a href="https://github.com/substrate-developer-hub/substrate-front-end-template#installation">substrate link</a> for installation
then use</p>
<pre><code class="language-sh">Yarn start
</code></pre>
<p>to connect a locally running node</p>
<h2 id="demo-purpose"><a class="header" href="#demo-purpose">Demo purpose</a></h2>
<p>In this demo, we want to demonstrate how OCW pallets can interact with the Garbled Circuit Factory to pilot the mass production of garbled circuits.</p>
<p>To avoid any ambiguities regarding the pallets delivered for this milestone (for demo/example purpose only), we named the two OCW pallets we interact with:</p>
<ul>
<li>ocwExample: to provide an example of how we can configure the GCF with a simple verilog file that will be used as a master file for production.</li>
<li>ocwDemo: to demomstrate how we can launch the production of the garbled circuits in the GCF.</li>
</ul>
<h2 id="demo-overview"><a class="header" href="#demo-overview">Demo overview:</a></h2>
<h3 id="1-write-a-verilog-masterconfig-filev-in-ipfs-and-get-its-verilogcid"><a class="header" href="#1-write-a-verilog-masterconfig-filev-in-ipfs-and-get-its-verilogcid">1. write a verilog master/config file.v in IPFS and get its <code>VerilogCid</code></a></h3>
<p><code>GCF: can be set-up</code> for production <strong>with verilog master file</strong></p>
<h3 id="2-signed-extrinsic-with-verilogcid-of-masterconfig-filev-to-ocwexample-pallet"><a class="header" href="#2-signed-extrinsic-with-verilogcid-of-masterconfig-filev-to-ocwexample-pallet">2. signed extrinsic with <code>VerilogCid</code> of master/config file.v to <code>ocwExample</code> pallet</a></h3>
<p><code>Request-&gt;GCF</code>: <strong>OCW launch  the generation of the logical circuit file in GCF</strong></p>
<p><code>Response&lt;-GCF</code>: <strong>OCW get the  <code>skcdCid</code> of the generated logical circuit (.skcd)</strong></p>
<p><code>GCF: GC production ready</code> for the production of Garbled Circuits: 
<strong>OCW is configured with verilog master file</strong></p>
<blockquote>
<p>skcd file is cached in the production pipeline</p>
</blockquote>
<h3 id="3-signed-extrinsic-with-skcdcid-to-ocwdemo-pallet"><a class="header" href="#3-signed-extrinsic-with-skcdcid-to-ocwdemo-pallet">3. signed extrinsic with <code>skcdCid</code> to <code>ocwDemo</code> pallet</a></h3>
<p><code>Request-&gt;GCF</code>: <strong>OCW launch  the generation of the garbled circuit files in GCF</strong></p>
<p><code>Response&lt;-GCF</code>: <strong>OCW get the <code>gcCid</code> of the generated garbled circuits (ready to be evaluated)</strong></p>
<blockquote>
<p>As the purpose of the demo is to illustrate the interaction between the OCWs and the GCF, we will lauch the garbled circuit production manualy using Pallet Interactor.</p>
</blockquote>
<h2 id="step-1-add-the-masterconfig-verilogfilev-in-ipfs"><a class="header" href="#step-1-add-the-masterconfig-verilogfilev-in-ipfs">Step 1: add the master/config verilogfile.v in IPFS</a></h2>
<p>As an example, we provide a very simple adder circuit:</p>
<p>adder.v</p>
<pre><code class="language-verilog editable">// https://www.geeksforgeeks.org/full-adder-using-verilog-hdl/

// Code your design : Full Adder
module full_add(a,b,cin,sum,cout);
  input a,b,cin;
  output sum,cout;
  wire x,y,z;

// instantiate building blocks of full adder
  half_add h1(.a(a),.b(b),.s(x),.c(y));
  half_add h2(.a(x),.b(cin),.s(sum),.c(z));
  or o1(cout,y,z);
endmodule : full_add

// code your half adder design
module half_add(a,b,s,c);
  input a,b;
  output s,c;

// gate level design of half adder
  xor x1(s,a,b);
  and a1(c,a,b);
endmodule :half_add
</code></pre>
<p>create a file <code>adder.v</code> eg</p>
<ul>
<li>use your editor of choice eg <code>code adder.v</code> or <code>nano adder.v</code> etc</li>
<li>copy paste the content above</li>
</ul>
<p>then</p>
<pre><code class="language-sh">curl -X POST -F file=@adder.v &quot;http://127.0.0.1:5001/api/v0/add?progress=true&quot;
</code></pre>
<p>The command result is:</p>
<pre><code>{&quot;Name&quot;:&quot;adder.v&quot;,&quot;Bytes&quot;:527}
{&quot;Name&quot;:&quot;adder.v&quot;,&quot;Hash&quot;:&quot;QmYAFySLrUXwf4wVb7QGMxA7nXAoueXtQCYpyReFp5NKsx&quot;,&quot;Size&quot;:&quot;538&quot;}
</code></pre>
<p><img src="./fig/curladderresult.png" alt="curl add adder result" /></p>
<p>the &quot;hash&quot; ie QmYAFySLrUXwf4wVb7QGMxA7nXAoueXtQCYpyReFp5NKsx is the  value expected for the 'VerilogCid' field in the pallet interactor </p>
<h2 id="interact-with-substrate-front-end"><a class="header" href="#interact-with-substrate-front-end">Interact with Substrate Front End</a></h2>
<p>We use Pallet Interactor to pilot the configuration and generation management of the circuits with GCF</p>
<h2 id="step-2-submit-verilogcid-with-pallet-interactor"><a class="header" href="#step-2-submit-verilogcid-with-pallet-interactor">Step 2: Submit <code>VerilogCid</code> with pallet Interactor</a></h2>
<h4 id="21-go-to-ocwexample-pallet-and--and-input-the-verilogcid-you-got-at-step-1"><a class="header" href="#21-go-to-ocwexample-pallet-and--and-input-the-verilogcid-you-got-at-step-1">2.1 Go to <code>ocwExample</code> pallet and  and input the <code>VerilogCid</code> you got at step 1.</a></h4>
<p>We use this pallet to submit the master/config  file example.</p>
<blockquote>
<p>please use the signed button</p>
</blockquote>
<p><img src="./fig/ocwExample.png" alt="ocwExample" /></p>
<p>GCF will generate the related skcd logical circuit file,  add it in IPFS and send back its hash i.e skcdCid to the <code>ocwExample</code> pallet.</p>
<h4 id="22-the-skcdcid-of-the-master-file-should-appear-in-the-log-of-the-node-example-hello-from-pallet-ocw"><a class="header" href="#22-the-skcdcid-of-the-master-file-should-appear-in-the-log-of-the-node-example-hello-from-pallet-ocw">2.2 The skcdCid of the master file should appear in the log of the node ([example] Hello from pallet-ocw)</a></h4>
<pre><code class="language-sh">2022-03-11 18:38:35 💤 Idle (0 peers), best: #12141 (0x61dd…ab06), finalized #12139 (0xe4bf…9f35), ⬇ 0 ⬆ 0    
2022-03-11 18:38:36 🙌 Starting consensus session on top of parent 0x61dd629bedb966389196018cf2cafacd9d529ec26d304545b283454e6d2dab06    
2022-03-11 18:38:36 🎁 Prepared block for proposing at 12142 [hash: 0xa463c744bce8948476af640d07031460646d1b48c8823e5ba4618da5be72175b; parent_hash: 0x61dd…ab06; extrinsics (1): [0x3f1f…b797]]    
2022-03-11 18:38:36 🔖 Pre-sealed block for proposal at 12142. Hash now 0xa72ffa4ced99481ebeeae2a14668ac719669d694a1e5fcfbf6a68fd64b909501, previously 0xa463c744bce8948476af640d07031460646d1b48c8823e5ba4618da5be72175b.    
2022-03-11 18:38:36 ✨ Imported #12142 (0xa72f…9501)    
2022-03-11 18:38:36 [example] Hello from pallet-ocw.    
2022-03-11 18:38:36 [example] sending body b64: AAAAADAKLlFtWExtUWJwZkRkWjRZc0ZBS2tzOXFQcUtiNVRaWlN3VG81RTd6SHhqUTFBNUc=    
2022-03-11 18:38:36 [example] status code: 200    
2022-03-11 18:38:36 [example] header: content-type application/grpc-web+proto    
2022-03-11 18:38:36 [example] header: transfer-encoding chunked    
2022-03-11 18:38:36 [example] header: date Fri, 11 Mar 2022 17:38:36 GMT    
2022-03-11 18:38:36 [example] Got gRPC trailers: grpc-status:0
    
2022-03-11 18:38:36 [example] Got IPFS hash: QmZ9UJbraZTjnkCYy7FTZWDaiv2s6qWTzfFNhFLgHJRfuh    
2022-03-11 18:38:36 [example] fetch_n_parse: QmZ9UJbraZTjnkCYy7FTZWDaiv2s6qWTzfFNhFLgHJRfuh    
2022-03-11 18:38:36 [example] FINAL got result IPFS hash : [b8, 51, 6d, 5a, 39, 55, 4a, 62, 72, 61, 5a, 54, 6a, 6e, 6b, 43, 59, 79, 37, 46, 54, 5a, 57, 44, 61, 69, 76, 32, 73, 36, 71, 57, 54, 7a, 66, 46, 4e, 68, 46, 4c, 67, 48, 4a, 52, 66, 75, 68] 
</code></pre>
<h4 id="23-copy-the-skcdcid-in-the-log"><a class="header" href="#23-copy-the-skcdcid-in-the-log">2.3 Copy the skcdCid in the log</a></h4>
<p>The <code>skcdCid</code> is displayed in the logs after [example] Got IPFS hash:</p>
<p>it's value for this example is: QmZ9UJbraZTjnkCYy7FTZWDaiv2s6qWTzfFNhFLgHJRfuh</p>
<h2 id="step-3-submit-skcdcid-with--pallet-interactor"><a class="header" href="#step-3-submit-skcdcid-with--pallet-interactor">Step 3: Submit <code>skcdCid</code> with  pallet Interactor</a></h2>
<p>We want to submit the cid of the skcd file to the pallet that will manage the production of garbled circuits.</p>
<h4 id="31-go-to-ocwdemo-pallet-and-input-the-skcdcid-copied-step-23"><a class="header" href="#31-go-to-ocwdemo-pallet-and-input-the-skcdcid-copied-step-23">3.1 Go to <code>ocwDemo</code> pallet and input the <code>skcdCid</code> copied (step 2.3)</a></h4>
<blockquote>
<p>please use the signed button</p>
</blockquote>
<p><img src="./fig/ocwDemo.png" alt="ocwDemo" /></p>
<p>The ocwDemo now will use with this logical circuit file  to produce garbled circuits.</p>
<h4 id="32-the-garbled-circuits-cids-appear-in-node-log-ocw-hello-from-pallet-ocw"><a class="header" href="#32-the-garbled-circuits-cids-appear-in-node-log-ocw-hello-from-pallet-ocw">3.2 The Garbled Circuits cids appear in node log ([ocw] Hello from pallet-ocw)</a></h4>
<p>The garbled circuits cids produced by the GCF are received by the <code>ocwDemo</code> pallet.</p>
<pre><code class="language-sh  editable">2022-03-11 18:38:36 [ocw] Hello from pallet-ocw.    
2022-03-11 18:38:36 [ocw] encode_body2: [51, 6d, 5a, 39, 55, 4a, 62, 72, 61, 5a, 54, 6a, 6e, 6b, 43, 59, 79, 37, 46, 54, 5a, 57, 44, 61, 69, 76, 32, 73, 36, 71, 57, 54, 7a, 66, 46, 4e, 68, 46, 4c, 67, 48, 4a, 52, 66, 75, 68]    
2022-03-11 18:38:36 [ocw] sending body b64: AAAAADAKLlFtWjlVSmJyYVpUam5rQ1l5N0ZUWldEYWl2MnM2cVdUemZGTmhGTGdISlJmdWg=    
2022-03-11 18:38:36 [ocw] status code: 200    
2022-03-11 18:38:36 [ocw] header: content-type application/grpc-web+proto    
2022-03-11 18:38:36 [ocw] header: transfer-encoding chunked    
2022-03-11 18:38:36 [ocw] header: date Fri, 11 Mar 2022 17:38:36 GMT    
2022-03-11 18:38:36 [ocw] Got gRPC trailers: grpc-status:0
    
2022-03-11 18:38:36 [ocw] Got IPFS hash: QmPUDRnaJG6wp22hMALAWKpyAwTZDts3vCZJmHZWWkXZJj    
2022-03-11 18:38:36 [ocw] fetch_n_parse: QmPUDRnaJG6wp22hMALAWKpyAwTZDts3vCZJmHZWWkXZJj    
2022-03-11 18:38:36 [ocw] FINAL got result IPFS hash : [b8, 51, 6d, 50, 55, 44, 52, 6e, 61, 4a, 47, 36, 77, 70, 32, 32, 68, 4d, 41, 4c, 41, 57, 4b, 70, 79, 41, 77, 54, 5a, 44, 74, 73, 33, 76, 43, 5a, 4a, 6d, 48, 5a, 57, 57, 6b, 58, 5a, 4a, 6a]   
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m2-delivery"><a class="header" href="#m2-delivery">M2 Delivery</a></h1>
<p>Unless you are already familliar with Interstellar technology please have a look at Garbled Circuit Factory and Trusted Transaction Validation protocol overviews</p>
<h2 id="garbled-circuit-factory-gcf-overview"><a class="header" href="#garbled-circuit-factory-gcf-overview">Garbled Circuit Factory (GCF) overview</a></h2>
<ul>
<li><a href="./GCF.html">GCF generic pipeline for Garbled Circuit (GC) production</a>
<ul>
<li><a href="./GC.html">Basic GC structure</a></li>
<li><a href="./VC-GC.html">Visual Cryptography display principles</a></li>
</ul>
</li>
</ul>
<h2 id="trusted-transaction-validation-protocol-ttvp-overview"><a class="header" href="#trusted-transaction-validation-protocol-ttvp-overview">Trusted Transaction Validation Protocol (TTVP) overview</a></h2>
<ul>
<li><a href="./TTVP.html">Trusted Transaction Validation Protocol</a>
<ul>
<li><a href="./TAUI.html">Trusted Authentication &amp; UI Layer</a></li>
<li><a href="./TTVP_detailed.html">TTVP detailed</a></li>
</ul>
</li>
</ul>
<h2 id="code-documentation-1"><a class="header" href="#code-documentation-1">Code documentation</a></h2>
<ul>
<li><a href="./GCF_pipeline_detailed.html">GCF detailed pipeline for the production of display circuits</a></li>
<li><a href="./GCF_API.html">GCF APIs for GCF OCWs</a></li>
</ul>
<h2 id="docker-demo-tutorial-1"><a class="header" href="#docker-demo-tutorial-1">Docker demo tutorial</a></h2>
<p><a href="./M2_demo_tutorial.html">Demo tutorial</a></p>
<h2 id="testing-guide-1"><a class="header" href="#testing-guide-1">Testing Guide</a></h2>
<blockquote>
<p>Following is a testing guide and tutorial to launch tests related to M2 milestone Mostly integration test. It also includes the prerequiste i.e additional software and libraries that need to be installed in order to run the unit tests without the M2 dockers.</p>
</blockquote>
<p>(not required if already tested with M1 delivery)</p>
<p><a href="https://book.interstellar.gg/GCF_API_Test_Guide.html">GCF APIs Testing Guide</a></p>
<h2 id="article-1"><a class="header" href="#article-1">Article</a></h2>
<p><a href="https://medium.com/@jlleleu/web3-foundation-and-interstellar-protocol-b4003a64e927">Draft Link to medium article: Web 3 Foundation and Interstellar Protocol</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m2-docker-demo-tutorial"><a class="header" href="#m2-docker-demo-tutorial">M2 Docker Demo Tutorial</a></h1>
<h2 id="check-prerequiste"><a class="header" href="#check-prerequiste">Check prerequiste</a></h2>
<p><a href="./runtime_prerequisite.html">runtime prerequiste</a></p>
<h2 id="set-up-demo-1"><a class="header" href="#set-up-demo-1">Set-up Demo</a></h2>
<h3 id="launch-ipfs-deamon-1"><a class="header" href="#launch-ipfs-deamon-1">Launch ipfs deamon</a></h3>
<pre><code class="language-sh">export GO_IPFS_PATH=/usr/local/bin/ipfs
</code></pre>
<pre><code class="language-sh">IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH init -p test
</code></pre>
<pre><code class="language-sh">IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH config Addresses.API /ip4/0.0.0.0/tcp/5001
</code></pre>
<pre><code class="language-sh">IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH daemon --enable-pubsub-experiment
</code></pre>
<pre><code class="language-sh">Initializing daemon...
go-ipfs version: 0.11.0
Repo version: 11
System version: amd64/linux
Golang version: go1.16.12
Swarm listening on /ip4/127.0.0.1/tcp/46507
Swarm listening on /p2p-circuit
Swarm announcing /ip4/127.0.0.1/tcp/46507
API server listening on /ip4/0.0.0.0/tcp/5001
WebUI: http://0.0.0.0:5001/webui
Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/38297
Daemon is ready
</code></pre>
<h3 id="launch-dockers-1"><a class="header" href="#launch-dockers-1">Launch dockers:</a></h3>
<blockquote>
<p>--ipfs-server-multiaddr value depends on your own environment
The example value should work with a standard docker installation.</p>
</blockquote>
<h4 id="launch-api_circuit-docker-1"><a class="header" href="#launch-api_circuit-docker-1">Launch api_circuit docker</a></h4>
<pre><code class="language-sh">docker run -it --name api_circuits --rm -p 3000:3000 --env RUST_LOG=&quot;warn,info,debug&quot; ghcr.io/interstellar-network/api_circuits:milestone2 /usr/local/bin/api_circuits --ipfs-server-multiaddr /ip4/172.17.0.1/tcp/5001
</code></pre>
<h4 id="launch-api_garble-docker-1"><a class="header" href="#launch-api_garble-docker-1">Launch api_garble docker</a></h4>
<pre><code class="language-sh">docker run -it --name api_garble --rm -p 3001:3000 --env RUST_LOG=&quot;warn,info,debug&quot; ghcr.io/interstellar-network/api_garble:milestone2 /usr/local/bin/api_garble --ipfs-server-multiaddr /ip4/172.17.0.1/tcp/5001
</code></pre>
<h3 id="launch-substrate-demo-chain-with-ocw-1"><a class="header" href="#launch-substrate-demo-chain-with-ocw-1">Launch substrate demo chain with OCW</a></h3>
<pre><code>git clone --branch=master --recursive git@github.com:Interstellar-Network/substrate-offchain-worker-demo.git
</code></pre>
<p>then</p>
<pre><code>cd substrate-offchain-worker-demo 
</code></pre>
<p>build and run the substrate chain....</p>
<pre><code class="language-sh">RUST_LOG=&quot;warn,info&quot; cargo run -- --dev --tmp --enable-offchain-indexing=1
</code></pre>
<blockquote>
<p>IMPORTANT: you MUST use --enable-offchain-indexing=1 else it will always do nothing and show &quot;[ocw-garble] nothing to do, returning...&quot; and &quot;[ocw-circuits] nothing to do, returning...&quot; in the logs</p>
</blockquote>
<h3 id="launch-a-generic-substrate-fromt-end-1"><a class="header" href="#launch-a-generic-substrate-fromt-end-1">Launch a generic Substrate Fromt-end</a></h3>
<p>Use the following <a href="https://substrate-developer-hub.github.io/substrate-front-end-template/?rpc=ws%3A%2F%2Flocalhost%3A9944">substrate link</a> to launch substrate front end</p>
<p>to connect to a locally running node</p>
<blockquote>
<p>avoid some browser extensions that could generate interface issues</p>
</blockquote>
<h2 id="demo-purpose-and-used-components"><a class="header" href="#demo-purpose-and-used-components">Demo purpose and used components</a></h2>
<p>In this demo, we want to demonstrate how:</p>
<ul>
<li>ocwCircuits and ocwGarble pallets can manage the production of the display garbled circuits </li>
<li>the Transaction Validation Protocol TTVP pallet can confirm the transactions based on those circuit evaluations/executions</li>
</ul>
<p><code>ocwCircuits</code>: can manage the generation of the logical display circuit in <code>skcd format</code> to configure the garbled circuit production.</p>
<blockquote>
<p>the generation of this configuration display circuit uses a Master File VHDL packages (pre-configured for that demo).</p>
</blockquote>
<p><code>ocwGarble</code>: can generate for each transaction a randomized display garbled circuit (with random Keypad and one time code) with a customized message based on transaction parameters</p>
<p><code>GCevaluator</code>: evaluates the garbled circuit/display message and get the one time code to verify</p>
<p><code>TTVP</code>: checks that the one time code is correct</p>
<h2 id="demo-overview-1"><a class="header" href="#demo-overview-1">Demo overview:</a></h2>
<h3 id="1-generate-with-ocwcircuits-pallet-the-configuration-display-circuit"><a class="header" href="#1-generate-with-ocwcircuits-pallet-the-configuration-display-circuit">1. Generate with <code>ocwCircuits</code> pallet the configuration display circuit</a></h3>
<blockquote>
<p>This step will generate a logical circuit in skcd format cached in memory in the production pipeline</p>
</blockquote>
<h3 id="2-generate-with-ocwgarble-pallet-a-randomized-display-garble-circuit"><a class="header" href="#2-generate-with-ocwgarble-pallet-a-randomized-display-garble-circuit">2. Generate with <code>ocwGarble</code> pallet a randomized display garble circuit</a></h3>
<blockquote>
<p>This step will use skcd cached file and input parameter to generate a randomized garbled circuit customized with transaction parameter
in this demo we do not use yet, other circuit customization parameters like screen resolution, etc...</p>
</blockquote>
<h3 id="3-evaluation-of-the-display-garbled-circuit-with-garbled-circuit-evaluator-to-display-transaction-message-and-one-time-code"><a class="header" href="#3-evaluation-of-the-display-garbled-circuit-with-garbled-circuit-evaluator-to-display-transaction-message-and-one-time-code">3. Evaluation of the display garbled circuit with <code>Garbled Circuit evaluator</code> to display transaction message and one time code</a></h3>
<h3 id="4-check-one-time-code-with-ttvp-pallet-ie-txvalidation"><a class="header" href="#4-check-one-time-code-with-ttvp-pallet-ie-txvalidation">4. Check one time code with <code>TTVP pallet</code> i.e txValidation</a></h3>
<h1 id="start-demo"><a class="header" href="#start-demo">Start Demo</a></h1>
<blockquote>
<p>IMPORTANT: when interacting with pallets you MUST use the Signed button in blue to sign all the transactions, not SUDO, neither Unsigned</p>
</blockquote>
<blockquote>
<p>step 1,2 &amp; 4 use pallet interactor in the Substrate Front End</p>
</blockquote>
<h2 id="1-generate-with-ocwcircuits-the-configuration-display-circuit"><a class="header" href="#1-generate-with-ocwcircuits-the-configuration-display-circuit">1. Generate with <code>ocwCircuits</code> the configuration display circuit</a></h2>
<h3 id="11--select-ocwcircuits-pallet-and-submitconfigdisplaysigned-extrinsic"><a class="header" href="#11--select-ocwcircuits-pallet-and-submitconfigdisplaysigned-extrinsic">1.1  Select ocwCircuits pallet and submitConfigDisplaySigned extrinsic</a></h3>
<p><img src="./fig/1ocwCircuitSelect.png" alt="circuit select" /></p>
<h3 id="12-sign-transaction"><a class="header" href="#12-sign-transaction">1.2 Sign transaction</a></h3>
<p><img src="./fig/2ocwCircuit.png" alt="circuit sign" /></p>
<h3 id="13-copy-the-ipfs-hashcid-of-the-generated-skcd-file"><a class="header" href="#13-copy-the-ipfs-hashcid-of-the-generated-skcd-file">1.3 Copy the ipfs hash/cid of the generated skcd file</a></h3>
<blockquote>
<p>the cid appears in Events (blue dot on this screenshot example)</p>
</blockquote>
<p><img src="./fig/3ocwCircuitResult.png" alt="circuit sign" /></p>
<h2 id="2-generate-with-ocwgarble-a-randomized-display-garble-circuit"><a class="header" href="#2-generate-with-ocwgarble-a-randomized-display-garble-circuit">2. Generate with <code>ocwGarble</code> a randomized display garble circuit</a></h2>
<p>This circuit can display a transaction message with one time code and a random keypad</p>
<h3 id="21-select-ocwgarble-pallet-and-garbleandstripsigned-extrinsic"><a class="header" href="#21-select-ocwgarble-pallet-and-garbleandstripsigned-extrinsic">2.1 Select ocwGarble pallet and garbleAndStripSigned extrinsic</a></h3>
<p><img src="./fig/1ocwGarbleSelect.png" alt="garble select" /></p>
<h3 id="22-input-skcdcid-and-transaction-message"><a class="header" href="#22-input-skcdcid-and-transaction-message">2.2 Input skcdCid and Transaction message</a></h3>
<p><img src="./fig/2ocwGarbleInput.png" alt="garble input 2 " /></p>
<h4 id="221-paste-the-ipfs-hashcid-of-step-13-in-field-skcdcid"><a class="header" href="#221-paste-the-ipfs-hashcid-of-step-13-in-field-skcdcid">2.2.1 Paste the ipfs hash/cid of step 1.3 in field skcdCid</a></h4>
<h4 id="222-input-the-message-in-field-txmsg"><a class="header" href="#222-input-the-message-in-field-txmsg">2.2.2 Input the message in field txMsg</a></h4>
<p><img src="./fig/3ocwGarbleInput.png" alt="garble input 3 " /></p>
<blockquote>
<p>the skcd cid is still in Events, blue dot in this example</p>
</blockquote>
<h4 id="223-sign-the-transaction"><a class="header" href="#223-sign-the-transaction">2.2.3 Sign the transaction</a></h4>
<h4 id="224-one-time-code-and-the-two-garbled-circuit-cids-appear-in-events"><a class="header" href="#224-one-time-code-and-the-two-garbled-circuit-cids-appear-in-events">2.2.4 One Time Code and the two garbled circuit cids appear in Events</a></h4>
<p><img src="./fig/4ocwGarbleResult.png" alt="garble result " /></p>
<p>The random One Time Code used for transaction validation appear in Events in the <code>txValidationDEBUGNewDigitSet</code> field (underlined with a red line in this screenshot example)</p>
<p>We can also check the random One Time Code securely embedded in the generated circuit in the api_garble logs and see that it matches the event mentioned field below.</p>
<p><img src="./fig/garble_log_OTC.png" alt="garble result ex " /></p>
<p>In this example the one time code value is 81 i.e. 0x0801 in Events and [8, 1] in api_garble logs.</p>
<blockquote>
<p>remark: it is important to mention that the number of digits used for transaction validation is not limited and can be easily configured (in upcoming TTVP APIs).</p>
</blockquote>
<p>The two generated garbled circuit cids to evaluate  appears in Events <code>NewGarbledIpfsCid</code>  (also underlined with red line)</p>
<p>In this example, the two respectives cids value are &quot;QmcXBLtfPxWVPgfQm6tnzcBg7KvzN7b9nNpVB4JPtHQEww&quot;,&quot;QmYKMiVWKKG5aYnHKp8shSVGLKCejv2jYCePZ6skkdaVhx&quot;</p>
<blockquote>
<p>matching respectively the pgarbled.pb.bin &amp; packmsg.pb.bin we will be evaluated on the next step</p>
</blockquote>
<h3 id="23-copy-the-hashs-of-the-two-generated-display-garbled-circuits-ready-to-be-avaluated"><a class="header" href="#23-copy-the-hashs-of-the-two-generated-display-garbled-circuits-ready-to-be-avaluated">2.3 Copy the hashs of the two generated display garbled circuits (ready to be avaluated)</a></h3>
<blockquote>
<p>remark: actually, the display circuit is composed of two subcircuits on for the display of transaction message and another which securely embed the one time code.</p>
</blockquote>
<blockquote>
<p>there is also another circuit that will display the random pinpad that we do not evaluate to make this demo simpler at this stage</p>
</blockquote>
<hr />
<blockquote>
<p>remark: you can specify any type of transaction message not especially tied to a wallet transaction. It can be used for any sensitive operation that need a highly secure confirmation</p>
</blockquote>
<p><img src="./fig/5ocwGarbleResult.png" alt="garble result ex " /></p>
<hr />
<h2 id="3-evaluation-of-the-display-garbled-circuits-with-the-evaluator-program-provided-in-a-docker"><a class="header" href="#3-evaluation-of-the-display-garbled-circuits-with-the-evaluator-program-provided-in-a-docker">3. Evaluation of the display garbled circuits with the evaluator program (provided in a docker)</a></h2>
<p>In this step we get the one time code to validate and check the transaction message</p>
<h3 id="31-first-create-a-folder-on-which-we-will-store-the-circuits"><a class="header" href="#31-first-create-a-folder-on-which-we-will-store-the-circuits">3.1 First create a folder on which we will store the circuits</a></h3>
<p>This folder will be mounted on the docker container to evaluate the two garbled circuits.</p>
<p>example:</p>
<pre><code class="language-sh">mkdir /tmp/evalcirc/
</code></pre>
<pre><code class="language-sh">cd /tmp/evalcirc/
</code></pre>
<blockquote>
<p>you can use any directory name, just pay attention that path is consistent with the following docker path parameters in step 3.2</p>
</blockquote>
<h3 id="32-create-the-garbled-circuits-in-the-above-folder"><a class="header" href="#32-create-the-garbled-circuits-in-the-above-folder">3.2 Create the garbled circuits in the above folder</a></h3>
<p>With the previously copied cids we then create respectively the <code>pgarbled.pb.bin</code> and <code>packmsg.pb.bin</code> garbled circuits files in the folder previously created to evaluate them with the evaluator.</p>
<pre><code class="language-sh">IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH cat QmcXBLtfPxWVPgfQm6tnzcBg7KvzN7b9nNpVB4JPtHQEww &gt; pgarbled.pb.bin
</code></pre>
<pre><code>IPFS_PATH=/tmp/ipfs $GO_IPFS_PATH cat QmYKMiVWKKG5aYnHKp8shSVGLKCejv2jYCePZ6skkdaVhx &gt; packmsg.pb.bin
</code></pre>
<h3 id="32-launch-the-evaluator-in-docker"><a class="header" href="#32-launch-the-evaluator-in-docker">3.2 Launch the evaluator in docker</a></h3>
<p>We can now launch the docker with the parameter below to perform the circuit evaluation.</p>
<p>if the docker host can use X11 (i.e. WSL2 or VM):</p>
<pre><code class="language-sh">docker run -it --rm -v $(pwd):/data/ -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY ghcr.io/interstellar-network/lib_garble:milestone2 --pgarbled_input_path=/data/pgarbled.pb.bin --packmsg_input_path=/data/packmsg.pb.bin
</code></pre>
<p>wait and an X11 windows will pop-up and display both the transaction message and the one time code</p>
<p><img src="./fig/EvaluationResultX11.png" alt="garble result X11 " /></p>
<p>else: </p>
<pre><code class="language-sh">docker run -it --rm -v $(pwd):/data/ ghcr.io/interstellar-network/lib_garble:milestone2 --pgarbled_input_path=/data/pgarbled.pb.bin --packmsg_input_path=/data/packmsg.pb.bin --png_output_path=/data/output_eval.png
</code></pre>
<p>In this case an output_eval.png file will be genrerated by the evaluator</p>
<blockquote>
<p>/tmp/evalcirc is the folder previously created and mounted in the docker container</p>
</blockquote>
<pre><code class="language-sh">/tmp/evalcirc$ ls
output_eval.png  packmsg.pb.bin  pgarbled.pb.bin
</code></pre>
<blockquote>
<p>We can check that it matches both the inputted message  and the random one time code (securely embedded in the circuit) to be validated: <code>81</code> in this example.</p>
</blockquote>
<hr />
<blockquote>
<p>remark: this specific garbled circuit evaluator does not reflect the look and feel of the final version that will be use on mobile (and delivered with the next M3 milestone).
As the purpose of the demo is only to demonstrate a part of the Transaction validation protocol, this circuit resolution is minimal and does not manage the generation of the random visual cryptography frames.</p>
</blockquote>
<p>if you want to check what the final version look like use the following link: <a href="https://www.interstellar.gg/simulation">Transaction validation screen simulations</a></p>
<h2 id="4-check-one-time-code-with-ttvp-pallet-ie-txvalidation-1"><a class="header" href="#4-check-one-time-code-with-ttvp-pallet-ie-txvalidation-1">4. Check one time code with <code>TTVP pallet</code> i.e. <code>txValidation</code></a></h2>
<h3 id="41-select-txvalidation-pallet-and-checkinput-extrinsic"><a class="header" href="#41-select-txvalidation-pallet-and-checkinput-extrinsic">4.1 Select <code>txValidation</code> pallet and <code>checkInput</code> extrinsic</a></h3>
<h3 id="42-submit-the-one-time-code-to-the-pallet-to-validate-it"><a class="header" href="#42-submit-the-one-time-code-to-the-pallet-to-validate-it">4.2 Submit the one time code to the pallet to validate it</a></h3>
<h3 id="421-paste-the-cid-of-the-first-garbled-circuit-generated-in-ipfscid-field"><a class="header" href="#421-paste-the-cid-of-the-first-garbled-circuit-generated-in-ipfscid-field">4.2.1 Paste the cid of the first garbled circuit generated in <code>ipfsCid</code> field</a></h3>
<p>His value is <code>QmcXBLtfPxWVPgfQm6tnzcBg7KvzN7b9nNpVB4JPtHQEww</code> in our example. It matches the garble circuit i.e. <code>pgarbled.pb.bin</code> file that embed the one time code</p>
<h3 id="422-enter-the-code-you-read-in-the-previous-step-in-inputdigits-field"><a class="header" href="#422-enter-the-code-you-read-in-the-previous-step-in-inputdigits-field">4.2.2 Enter the code you read in the previous step in <code>inputDigits</code> field</a></h3>
<p>This is the two-digit code you read on the X11 pop-up or by displaying the <code>output_eval.png</code> image</p>
<h3 id="423-sign"><a class="header" href="#423-sign">4.2.3 Sign</a></h3>
<p><img src="./fig/txValOK.png" alt="check OK" /></p>
<h3 id="43-we-can-also-check-the-pallet-with-a-wrong-code"><a class="header" href="#43-we-can-also-check-the-pallet-with-a-wrong-code">4.3 We can also check the pallet with a wrong code</a></h3>
<p><img src="./fig/txValKO.png" alt="check KO" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m3-delivery"><a class="header" href="#m3-delivery">M3 Delivery</a></h1>
<p>Unless you are already familliar with Interstellar technology please have a look at Garbled Circuit Factory </p>
<h2 id="garbled-circuit-factory-gcf-overview-1"><a class="header" href="#garbled-circuit-factory-gcf-overview-1">Garbled Circuit Factory (GCF) overview</a></h2>
<ul>
<li><a href="./GCF.html">GCF generic pipeline for Garbled Circuit (GC) production</a>
<ul>
<li><a href="./GC.html">Basic GC structure</a></li>
<li><a href="./VC-GC.html">Visual Cryptography display principles</a></li>
</ul>
</li>
</ul>
<h2 id="updated-trusted-transaction-validation-protocol-ttvp-overview"><a class="header" href="#updated-trusted-transaction-validation-protocol-ttvp-overview">Updated Trusted Transaction Validation Protocol (TTVP) overview</a></h2>
<ul>
<li><a href="./TTVP.html">Trusted Transaction Validation Protocol</a>
<ul>
<li><a href="./TAUI.html">Trusted Authentication &amp; UI Layer</a></li>
<li><a href="./TTVP_detailed.html">TTVP detailed</a></li>
</ul>
</li>
</ul>
<h2 id="code-documentation-2"><a class="header" href="#code-documentation-2">Code documentation</a></h2>
<h2 id="mobile-tee-registry-1"><a class="header" href="#mobile-tee-registry-1">Mobile TEE Registry</a></h2>
<ul>
<li><a href="./Mobile_Registry.html">Mobile Registry</a></li>
</ul>
<h2 id="mobile-wallet-app-demo"><a class="header" href="#mobile-wallet-app-demo">Mobile Wallet App Demo</a></h2>
<ul>
<li><a href="./Mobile_App.html">Mobile Wallet App</a>
<ul>
<li><a href="./TTVP_client.html">TTVP Client</a></li>
<li><a href="./HBMK.html">Hardware-backed Mobile Key</a></li>
</ul>
</li>
</ul>
<h2 id="docker-demo-tutorial-2"><a class="header" href="#docker-demo-tutorial-2">Docker demo tutorial</a></h2>
<p><a href="./M3_demo_tutorial.html">Demo tutorial</a></p>
<h2 id="testing-guide-2"><a class="header" href="#testing-guide-2">Testing Guide</a></h2>
<blockquote>
<p>Following is a testing guide and tutorial to launch tests related to M2 milestone Mostly integration test. It also includes the prerequiste i.e additional software and libraries that need to be installed in order to run the unit tests without the M2 dockers.</p>
</blockquote>
<p>(not required if already tested with M1 delivery)</p>
<p><a href="https://book.interstellar.gg/GCF_API_Test_Guide.html">GCF APIs Testing Guide</a></p>
<p>All other tests are implemented in the CI workflow for the build of the blockchain and of the apps.</p>
<h2 id="article-2"><a class="header" href="#article-2">Article</a></h2>
<p>Updated <a href="https://medium.com/@jlleleu/web3-foundation-and-interstellar-protocol-b4003a64e927">Draft Link to medium article: Web 3 Foundation and Interstellar Protocol</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m3-demo-tutorial"><a class="header" href="#m3-demo-tutorial">M3 Demo Tutorial</a></h1>
<h2 id="prerequiste-docker-or-podman"><a class="header" href="#prerequiste-docker-or-podman">prerequiste: docker or podman</a></h2>
<p>install</p>
<ul>
<li>docker: https://docs.docker.com/engine/install/</li>
</ul>
<p>or </p>
<ul>
<li>podman: 
https://podman.io/getting-started/installation.html</li>
</ul>
<p>then</p>
<ul>
<li>docker-compose: https://docs.docker.com/compose/install/</li>
</ul>
<p>or</p>
<ul>
<li>podman-compose: https://github.com/containers/podman-compose#podman-compose</li>
</ul>
<h2 id="set-up-demo-2"><a class="header" href="#set-up-demo-2">Set-up Demo</a></h2>
<h3 id="1-launch-the-blockchain"><a class="header" href="#1-launch-the-blockchain">1. Launch the blockchain</a></h3>
<p>Create a directory</p>
<p>example:</p>
<pre><code>mkdir blockchain_demo
</code></pre>
<p>and add the following docker compose configuration file: <a href="https://github.com/Interstellar-Network/Interstellar-Book/blob/docker-compose/docker-compose.yml">docker-compose.yml</a> in it.</p>
<p>Then start docker or podman</p>
<pre><code>sudo service docker start
</code></pre>
<p>and then </p>
<pre><code>cd blockchain_demo
</code></pre>
<p>and launch the blockchain demo with <code>ipfs</code> and all api services i.e. <code>api_circuits</code> and <code>api_garble</code> with the following comand in the created directory.</p>
<pre><code>docker-compose down --timeout 1 &amp;&amp; docker-compose up --force-recreate
</code></pre>
<blockquote>
<p>replace <code>docker-compose</code> with <code>podman-compose</code> if you are using podman instead of docker</p>
</blockquote>
<h3 id="2-launch-a-generic-substrate-fromt-end"><a class="header" href="#2-launch-a-generic-substrate-fromt-end">2. Launch a generic Substrate Fromt-end</a></h3>
<p>Use the following <a href="https://substrate-developer-hub.github.io/substrate-front-end-template/?rpc=ws%3A%2F%2Flocalhost%3A9944">substrate link</a> to launch substrate front end</p>
<p>to connect to a locally running node</p>
<blockquote>
<p>avoid some browser extensions that could generate interface issues</p>
</blockquote>
<h3 id="3-install-the-wallet-app-ie-apk-file-on-an-android-device-or-an-emulator"><a class="header" href="#3-install-the-wallet-app-ie-apk-file-on-an-android-device-or-an-emulator">3. Install the wallet App i.e APK file on an android device or an emulator</a></h3>
<h4 id="31-retrieve-the-apk-file"><a class="header" href="#31-retrieve-the-apk-file">3.1 Retrieve the APK file</a></h4>
<p>Download the <a href="https://github.com/Interstellar-Network/wallet-app/releases/tag/milestone3">APK file</a></p>
<h4 id="32-install-the-apk"><a class="header" href="#32-install-the-apk">3.2 Install the APK</a></h4>
<h5 id="321-on-an-android-device"><a class="header" href="#321-on-an-android-device">3.2.1 on an android device</a></h5>
<p><a href="https://www.lifewire.com/install-apk-on-android-4177185">How to install an APK on Android</a></p>
<p>WARNING: ensure that your device is configure for english.</p>
<h5 id="322-on-an-windows-emulator"><a class="header" href="#322-on-an-windows-emulator">3.2.2 on an windows emulator</a></h5>
<p><a href="https://developer.android.com/studio/">Install Android studio</a></p>
<p>Install the pixel 5 API 31 emulator with Virtual Device Manager</p>
<h4 id="342-launch-the-emulator"><a class="header" href="#342-launch-the-emulator">3.4.2 Launch the emulator</a></h4>
<p><img src="./fig/Android_device_manager.png" alt="Launch pixel 5 API 31 emulator" /></p>
<p>Wait for the emulator to launch and emulated device to power on and drag and drop the APK file on the emulator to install the App.</p>
<h3 id="4-ensure-that-wallet-can-connect-to-the-blockchain"><a class="header" href="#4-ensure-that-wallet-can-connect-to-the-blockchain">4. Ensure that wallet can connect to the blockchain</a></h3>
<p>adb is installed by default with android studio.
So you just need to set-up its path on the OS used, if it is not already set.</p>
<p>Just connect the phone with an USB port or through WiFi( cf android studio).</p>
<p>on the OS where the emulator is installed or the device is connected:</p>
<pre><code>adb reverse tcp:5001 tcp:5001
</code></pre>
<pre><code>adb reverse tcp:9944 tcp:9944 
</code></pre>
<p>to expose server desktop on emulator</p>
<p>on the OS where blocchain is installed:</p>
<p>example if  blockchain run on WSL2</p>
<pre><code> export WSL_HOST_IP=&quot;$(tail -1 /etc/resolv.conf | cut -d' ' -f2)&quot;
</code></pre>
<p>and use SSH to connect to the device or emulator on windows:</p>
<pre><code>ssh -N -R 9944:localhost:9944 -R 5001:localhost:5001 [windows_user_name]@$WSL_HOST_IP
</code></pre>
<p>TROUBLESHOOTING: start the front-end
<a href="https://substrate-developer-hub.github.io/substrate-front-end-template/?rpc=ws%3A%2F%2Flocalhost%3A9944">substrate link</a>
on your Device/Emulator to check it works properly.
Otherwise fix network issues.</p>
<h2 id="demo-purpose-1"><a class="header" href="#demo-purpose-1">Demo purpose</a></h2>
<p>The purpose of this demo is to show how a mobile wallet can use the <a href="./TTVP_Client.html">Trusted Transaction Protocol client</a> to confirm a transaction in a higly secure and hardware-backed trusted way on a smartphone device.</p>
<p>We focus on demonstrating:</p>
<ol>
<li>The registration of the mobile device on the blockchain mobile registry.</li>
<li>The confirmation of a transaction through the TTVP protocol and the execution of the core low-level TTVP client on a smartphone device.</li>
</ol>
<blockquote>
<p>The purpose of the demo is not yet to show a fully functional wallet. We want to demonstrate that the TTVP protocol and Trusted Authentication and UI Layer is working as expected with our substrate based blockchain pallets to authenticate and confirm transactions or sensible operations.</p>
</blockquote>
<h2 id="start-the-demo"><a class="header" href="#start-the-demo">Start The demo</a></h2>
<h2 id="1-generate-with-ocwcircuits-the-configuration-display-circuit-package"><a class="header" href="#1-generate-with-ocwcircuits-the-configuration-display-circuit-package">1. Generate with <code>ocwCircuits</code> the configuration display circuit package</a></h2>
<blockquote>
<p>IMPORTANT: when interacting with pallets you MUST use the Signed button in blue to sign all the transactions, not SUDO, neither Unsigned</p>
</blockquote>
<blockquote>
<p>this is almost the same step one of the M2 delivery demo tutorial except that it generate of package of circuirts.</p>
</blockquote>
<p>It set-up the configuration display circuit package used by the Garble Circuit Factory to generate randomized keyboard and message with one time code for each transactions.</p>
<h3 id="11--select-ocwcircuits-pallet"><a class="header" href="#11--select-ocwcircuits-pallet">1.1  Select ocwCircuits pallet</a></h3>
<p><img src="./fig/select-ocwCircuits.png" alt="circuit select" /></p>
<h3 id="12-select-submitconfigdisplaypackagesigned-extrinsic"><a class="header" href="#12-select-submitconfigdisplaypackagesigned-extrinsic">1.2 select submitConfigDisplayPackageSigned extrinsic</a></h3>
<p><img src="./fig/select-circuit-display-package.png" alt="circuit select" /></p>
<h3 id="13-sign-transaction"><a class="header" href="#13-sign-transaction">1.3 Sign transaction</a></h3>
<p><img src="./fig/ocw-sign.png" alt="circuit sign" /></p>
<h3 id="13-the-cid-of-the-circuit-package-generated-appears-in-events"><a class="header" href="#13-the-cid-of-the-circuit-package-generated-appears-in-events">1.3 The cid of the circuit package generated appears in Events</a></h3>
<p><img src="./fig/ocw-show-event.png" alt="circuit sign" /></p>
<h2 id="2-launch-android-app"><a class="header" href="#2-launch-android-app">2. Launch Android App</a></h2>
<p>Swipe from bottom to top and click on <code>Wallet Interstellar</code></p>
<img src="./fig/SelectAndroidApp.png" alt="wallet menu"  width="120"/>
<h2 id="3-send-a-currency-and-wait-for-the-transaction-confirmation-screen-to-validate-the-transaction"><a class="header" href="#3-send-a-currency-and-wait-for-the-transaction-confirmation-screen-to-validate-the-transaction">3. Send a Currency and wait for the Transaction confirmation screen to validate the transaction</a></h2>
<h3 id="31-select-currency-and-contact"><a class="header" href="#31-select-currency-and-contact">3.1 Select currency and contact</a></h3>
<p>Following is an explicit video showing how to send a curency to a contact
on SEND screen.</p>
<img src="./fig/Send_Currency_Demo.gif" alt="wallet menu"  width="300"/>
<h3 id="32-click-on-the-blue-check-icon"><a class="header" href="#32-click-on-the-blue-check-icon">3.2 Click on the blue Check icon</a></h3>
<h3 id="33-wait-for-the-transaction-validation-screen-to-appear-and-type-the-two-digits-one-time-code"><a class="header" href="#33-wait-for-the-transaction-validation-screen-to-appear-and-type-the-two-digits-one-time-code">3.3 Wait for the transaction validation screen to appear and type the two-digits one-time-code</a></h3>
<p>NOTE:</p>
<blockquote>
<p>The wallet app is still work in progress and we have still some little issues to fix between the low level layer in rust and C++, especially on the renderer to connect with the Kotlin/Swift UI layer.</p>
</blockquote>
<p>We want to avoid writting code that won't be used in the final version. For this reason we have made some little shortcut to demonstrate the execution of validation screen based on Garbled Circuits package eveluation.</p>
<blockquote>
<p>As a result we do not show yet the inputted amount and the transaction beneficiary in the message. Although the transaction validation screen is fully functional.</p>
</blockquote>
<blockquote>
<p>Remark: Regarding the beneficiary of the transaction, we will implement a trusted beneficiary feature: a user will be able to create a trusted beneficiary contact whose public address will be registered in the blockchain through a sensitive operation message validation.</p>
</blockquote>
<p>This makes the classic public key address substitution impossible for an attacker. Bad actors won't be able to replace a contact name by their own public key.
Moreover, it makes the usage of the wallet much more user friendly and safer.</p>
<h2 id="4-check-that-mobile-public-key-is-registered-on-the-mobile-registry-pallet"><a class="header" href="#4-check-that-mobile-public-key-is-registered-on-the-mobile-registry-pallet">4. Check that mobile public key is registered on the mobile registry pallet</a></h2>
<h3 id="41-copy-the-account-key-in-mobileregistry-events"><a class="header" href="#41-copy-the-account-key-in-mobileregistry-events">4.1 Copy the <code>account key</code> in MobileRegistry Events</a></h3>
<p>When the mobile is registered with an account, its mobile public key is stored on mobileRegistryMap in <code>MobileRegistry</code> pallet and an event is generated</p>
<p><img src="./fig/MobileRegistryEvent.png" alt="circuit sign" /></p>
<blockquote>
<p>underline in red</p>
</blockquote>
<h3 id="42-select-mobileregistry-pallet"><a class="header" href="#42-select-mobileregistry-pallet">4.2 select mobileRegistry pallet</a></h3>
<p>and mobileRegistryMap Query (not extrinsic)</p>
<p><img src="./fig/select-MobileRegistry.png" alt="circuit sign" /></p>
<p>Then  paste the copied <code>account key</code></p>
<p><img src="./fig/MobileRegistryQuery.png" alt="circuit sign" /></p>
<p>When the Query is completed you will see the mobile public key associated with the device as a result.</p>
<blockquote>
<p>this public key is used to verify the hardware-backed signature of the transaction confirmation message that includes position typed by the user on the randomized keypad</p>
</blockquote>
<h2 id="5-check-mobile-users-ínput-and-transaction-status-on-the-front-end"><a class="header" href="#5-check-mobile-users-ínput-and-transaction-status-on-the-front-end">5. Check Mobile user's ínput and transaction status on the front-end</a></h2>
<p>Check the events</p>
<h3 id="51-transaction-success"><a class="header" href="#51-transaction-success">5.1 Transaction Success</a></h3>
<p>you will see in the events
<img src="./fig/TransactionSuccess.png" alt="circuit sign" />
if the one-time-code was entered properly</p>
<h3 id="52-transaction-fail"><a class="header" href="#52-transaction-fail">5.2 Transaction Fail</a></h3>
<p>you will see in the events
<img src="./fig/TransactionFail.png" alt="circuit sign" />
if the one-time-code was wrong</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apis-testing-guide"><a class="header" href="#apis-testing-guide">APIs Testing Guide</a></h1>
<p>This is the tests related to the gRPC APIs call to the GCF external service gRPC tokio server.</p>
<p>Those tests included in the tests folders of the following repositories <code>api_circuit</code> and <code>api_garble</code> wil demonstrate respectively:</p>
<ul>
<li>
<p>the generation of logical circuit files based on static generic verilog files and/or based on verilog files generated by a program e.g segmet2pixel.v combined with others verilog static files
cf <a href="./GCF_pipeline_detailed.html">Detailed Pipeline for Display Circuits</a></p>
</li>
<li>
<p>the generation of garbled circuits based on the previously generated .skcd files</p>
</li>
</ul>
<p>On this respect one generic very simple adder circuit is use as an example, as well as our pretty complexe display circuit that will be used to manage our Transaction Validation protocol.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p><a href="./compilation_prerequisite.html">compilation rerequiste</a></p>
<h2 id="repositories"><a class="header" href="#repositories">Repositories</a></h2>
<ul>
<li><a href="https://github.com/Interstellar-Network/api_circuits">Circuit APIs</a></li>
<li><a href="https://github.com/Interstellar-Network/api_garble">Garble APIs</a></li>
</ul>
<h3 id="first-clone-the-previous-repositories-with---recursive"><a class="header" href="#first-clone-the-previous-repositories-with---recursive">First clone the previous repositories with --recursive</a></h3>
<p>Circuit APIs</p>
<pre><code class="language-sh">git clone --recursive https://github.com/Interstellar-Network/api_circuits.git
</code></pre>
<p>Garble APIs</p>
<pre><code class="language-sh">git clone --recursive https://github.com/Interstellar-Network/api_garble.git
</code></pre>
<h3 id="export-ipfs-path"><a class="header" href="#export-ipfs-path">export IPFS path</a></h3>
<pre><code class="language-sh">export GO_IPFS_PATH=/usr/local/bin/ipfs
</code></pre>
<h3 id="launch-the-respectives--tests"><a class="header" href="#launch-the-respectives--tests">Launch the respectives  tests</a></h3>
<p><code>cargo test</code> in  <code>api_circuits</code> and <code>api_garble</code> repositories will run their respective tests</p>
<blockquote>
<p>In case of potential issues withe the build of c++ wrappers c++
you can execute this cmd to solve it <code>find target/ -type d -name &quot;*-wrapper-*&quot; -exec rm -rf {} \;</code></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
